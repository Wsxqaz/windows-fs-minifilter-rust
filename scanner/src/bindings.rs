// Bindings generated by `windows-bindgen` 0.55.0

#[repr(C)]
pub struct ACCESS_STATE {
    pub OperationID: LUID,
    pub SecurityEvaluated: BOOLEAN,
    pub GenerateAudit: BOOLEAN,
    pub GenerateOnClose: BOOLEAN,
    pub PrivilegesAllocated: BOOLEAN,
    pub Flags: u32,
    pub RemainingDesiredAccess: u32,
    pub PreviouslyGrantedAccess: u32,
    pub OriginalDesiredAccess: u32,
    pub SubjectSecurityContext: SECURITY_SUBJECT_CONTEXT,
    pub SecurityDescriptor: PSECURITY_DESCRIPTOR,
    pub AuxData: *mut core::ffi::c_void,
    pub Privileges: ACCESS_STATE_0,
    pub AuditPrivileges: BOOLEAN,
    pub ObjectName: UNICODE_STRING,
    pub ObjectTypeName: UNICODE_STRING,
}
impl Copy for ACCESS_STATE {}
impl Clone for ACCESS_STATE {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub union ACCESS_STATE_0 {
    pub InitialPrivilegeSet: INITIAL_PRIVILEGE_SET,
    pub PrivilegeSet: PRIVILEGE_SET,
}
impl Copy for ACCESS_STATE_0 {}
impl Clone for ACCESS_STATE_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct ACL {
    pub AclRevision: u8,
    pub Sbz1: u8,
    pub AclSize: u16,
    pub AceCount: u16,
    pub Sbz2: u16,
}
impl Copy for ACL {}
impl Clone for ACL {
    fn clone(&self) -> Self {
        *self
    }
}
pub type BOOLEAN = u8;
pub type BUS_QUERY_ID_TYPE = i32;
#[repr(C)]
pub struct CM_FULL_RESOURCE_DESCRIPTOR {
    pub InterfaceType: INTERFACE_TYPE,
    pub BusNumber: u32,
    pub PartialResourceList: CM_PARTIAL_RESOURCE_LIST,
}
impl Copy for CM_FULL_RESOURCE_DESCRIPTOR {}
impl Clone for CM_FULL_RESOURCE_DESCRIPTOR {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct CM_PARTIAL_RESOURCE_DESCRIPTOR {
    pub Type: u8,
    pub ShareDisposition: u8,
    pub Flags: u16,
    pub u: CM_PARTIAL_RESOURCE_DESCRIPTOR_0,
}
impl Copy for CM_PARTIAL_RESOURCE_DESCRIPTOR {}
impl Clone for CM_PARTIAL_RESOURCE_DESCRIPTOR {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub union CM_PARTIAL_RESOURCE_DESCRIPTOR_0 {
    pub Generic: CM_PARTIAL_RESOURCE_DESCRIPTOR_0_6,
    pub Port: CM_PARTIAL_RESOURCE_DESCRIPTOR_0_13,
    pub Interrupt: CM_PARTIAL_RESOURCE_DESCRIPTOR_0_7,
    pub MessageInterrupt: CM_PARTIAL_RESOURCE_DESCRIPTOR_0_12,
    pub Memory: CM_PARTIAL_RESOURCE_DESCRIPTOR_0_11,
    pub Dma: CM_PARTIAL_RESOURCE_DESCRIPTOR_0_5,
    pub DmaV3: CM_PARTIAL_RESOURCE_DESCRIPTOR_0_4,
    pub DevicePrivate: CM_PARTIAL_RESOURCE_DESCRIPTOR_0_2,
    pub BusNumber: CM_PARTIAL_RESOURCE_DESCRIPTOR_0_0,
    pub DeviceSpecificData: CM_PARTIAL_RESOURCE_DESCRIPTOR_0_3,
    pub Memory40: CM_PARTIAL_RESOURCE_DESCRIPTOR_0_8,
    pub Memory48: CM_PARTIAL_RESOURCE_DESCRIPTOR_0_9,
    pub Memory64: CM_PARTIAL_RESOURCE_DESCRIPTOR_0_10,
    pub Connection: CM_PARTIAL_RESOURCE_DESCRIPTOR_0_1,
}
impl Copy for CM_PARTIAL_RESOURCE_DESCRIPTOR_0 {}
impl Clone for CM_PARTIAL_RESOURCE_DESCRIPTOR_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct CM_PARTIAL_RESOURCE_DESCRIPTOR_0_0 {
    pub Start: u32,
    pub Length: u32,
    pub Reserved: u32,
}
impl Copy for CM_PARTIAL_RESOURCE_DESCRIPTOR_0_0 {}
impl Clone for CM_PARTIAL_RESOURCE_DESCRIPTOR_0_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct CM_PARTIAL_RESOURCE_DESCRIPTOR_0_1 {
    pub Class: u8,
    pub Type: u8,
    pub Reserved1: u8,
    pub Reserved2: u8,
    pub IdLowPart: u32,
    pub IdHighPart: u32,
}
impl Copy for CM_PARTIAL_RESOURCE_DESCRIPTOR_0_1 {}
impl Clone for CM_PARTIAL_RESOURCE_DESCRIPTOR_0_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct CM_PARTIAL_RESOURCE_DESCRIPTOR_0_2 {
    pub Data: [u32; 3],
}
impl Copy for CM_PARTIAL_RESOURCE_DESCRIPTOR_0_2 {}
impl Clone for CM_PARTIAL_RESOURCE_DESCRIPTOR_0_2 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct CM_PARTIAL_RESOURCE_DESCRIPTOR_0_3 {
    pub DataSize: u32,
    pub Reserved1: u32,
    pub Reserved2: u32,
}
impl Copy for CM_PARTIAL_RESOURCE_DESCRIPTOR_0_3 {}
impl Clone for CM_PARTIAL_RESOURCE_DESCRIPTOR_0_3 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct CM_PARTIAL_RESOURCE_DESCRIPTOR_0_4 {
    pub Channel: u32,
    pub RequestLine: u32,
    pub TransferWidth: u8,
    pub Reserved1: u8,
    pub Reserved2: u8,
    pub Reserved3: u8,
}
impl Copy for CM_PARTIAL_RESOURCE_DESCRIPTOR_0_4 {}
impl Clone for CM_PARTIAL_RESOURCE_DESCRIPTOR_0_4 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct CM_PARTIAL_RESOURCE_DESCRIPTOR_0_5 {
    pub Channel: u32,
    pub Port: u32,
    pub Reserved1: u32,
}
impl Copy for CM_PARTIAL_RESOURCE_DESCRIPTOR_0_5 {}
impl Clone for CM_PARTIAL_RESOURCE_DESCRIPTOR_0_5 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C, packed(4))]
pub struct CM_PARTIAL_RESOURCE_DESCRIPTOR_0_6 {
    pub Start: i64,
    pub Length: u32,
}
impl Copy for CM_PARTIAL_RESOURCE_DESCRIPTOR_0_6 {}
impl Clone for CM_PARTIAL_RESOURCE_DESCRIPTOR_0_6 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct CM_PARTIAL_RESOURCE_DESCRIPTOR_0_7 {
    pub Level: u32,
    pub Vector: u32,
    pub Affinity: usize,
}
impl Copy for CM_PARTIAL_RESOURCE_DESCRIPTOR_0_7 {}
impl Clone for CM_PARTIAL_RESOURCE_DESCRIPTOR_0_7 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C, packed(4))]
pub struct CM_PARTIAL_RESOURCE_DESCRIPTOR_0_8 {
    pub Start: i64,
    pub Length40: u32,
}
impl Copy for CM_PARTIAL_RESOURCE_DESCRIPTOR_0_8 {}
impl Clone for CM_PARTIAL_RESOURCE_DESCRIPTOR_0_8 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C, packed(4))]
pub struct CM_PARTIAL_RESOURCE_DESCRIPTOR_0_9 {
    pub Start: i64,
    pub Length48: u32,
}
impl Copy for CM_PARTIAL_RESOURCE_DESCRIPTOR_0_9 {}
impl Clone for CM_PARTIAL_RESOURCE_DESCRIPTOR_0_9 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C, packed(4))]
pub struct CM_PARTIAL_RESOURCE_DESCRIPTOR_0_10 {
    pub Start: i64,
    pub Length64: u32,
}
impl Copy for CM_PARTIAL_RESOURCE_DESCRIPTOR_0_10 {}
impl Clone for CM_PARTIAL_RESOURCE_DESCRIPTOR_0_10 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C, packed(4))]
pub struct CM_PARTIAL_RESOURCE_DESCRIPTOR_0_11 {
    pub Start: i64,
    pub Length: u32,
}
impl Copy for CM_PARTIAL_RESOURCE_DESCRIPTOR_0_11 {}
impl Clone for CM_PARTIAL_RESOURCE_DESCRIPTOR_0_11 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct CM_PARTIAL_RESOURCE_DESCRIPTOR_0_12 {
    pub Anonymous: CM_PARTIAL_RESOURCE_DESCRIPTOR_0_12_0,
}
impl Copy for CM_PARTIAL_RESOURCE_DESCRIPTOR_0_12 {}
impl Clone for CM_PARTIAL_RESOURCE_DESCRIPTOR_0_12 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub union CM_PARTIAL_RESOURCE_DESCRIPTOR_0_12_0 {
    pub Raw: CM_PARTIAL_RESOURCE_DESCRIPTOR_0_12_0_0,
    pub Translated: CM_PARTIAL_RESOURCE_DESCRIPTOR_0_12_0_1,
}
impl Copy for CM_PARTIAL_RESOURCE_DESCRIPTOR_0_12_0 {}
impl Clone for CM_PARTIAL_RESOURCE_DESCRIPTOR_0_12_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct CM_PARTIAL_RESOURCE_DESCRIPTOR_0_12_0_0 {
    pub Reserved: u16,
    pub MessageCount: u16,
    pub Vector: u32,
    pub Affinity: usize,
}
impl Copy for CM_PARTIAL_RESOURCE_DESCRIPTOR_0_12_0_0 {}
impl Clone for CM_PARTIAL_RESOURCE_DESCRIPTOR_0_12_0_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct CM_PARTIAL_RESOURCE_DESCRIPTOR_0_12_0_1 {
    pub Level: u32,
    pub Vector: u32,
    pub Affinity: usize,
}
impl Copy for CM_PARTIAL_RESOURCE_DESCRIPTOR_0_12_0_1 {}
impl Clone for CM_PARTIAL_RESOURCE_DESCRIPTOR_0_12_0_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C, packed(4))]
pub struct CM_PARTIAL_RESOURCE_DESCRIPTOR_0_13 {
    pub Start: i64,
    pub Length: u32,
}
impl Copy for CM_PARTIAL_RESOURCE_DESCRIPTOR_0_13 {}
impl Clone for CM_PARTIAL_RESOURCE_DESCRIPTOR_0_13 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct CM_PARTIAL_RESOURCE_LIST {
    pub Version: u16,
    pub Revision: u16,
    pub Count: u32,
    pub PartialDescriptors: [CM_PARTIAL_RESOURCE_DESCRIPTOR; 1],
}
impl Copy for CM_PARTIAL_RESOURCE_LIST {}
impl Clone for CM_PARTIAL_RESOURCE_LIST {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct CM_RESOURCE_LIST {
    pub Count: u32,
    pub List: [CM_FULL_RESOURCE_DESCRIPTOR; 1],
}
impl Copy for CM_RESOURCE_LIST {}
impl Clone for CM_RESOURCE_LIST {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct COMPRESSED_DATA_INFO {
    pub CompressionFormatAndEngine: u16,
    pub CompressionUnitShift: u8,
    pub ChunkShift: u8,
    pub ClusterShift: u8,
    pub Reserved: u8,
    pub NumberOfChunks: u16,
    pub CompressedChunkSizes: [u32; 1],
}
impl Copy for COMPRESSED_DATA_INFO {}
impl Clone for COMPRESSED_DATA_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct DEVICE_CAPABILITIES {
    pub Size: u16,
    pub Version: u16,
    pub _bitfield: u32,
    pub Address: u32,
    pub UINumber: u32,
    pub DeviceState: [DEVICE_POWER_STATE; 7],
    pub SystemWake: SYSTEM_POWER_STATE,
    pub DeviceWake: DEVICE_POWER_STATE,
    pub D1Latency: u32,
    pub D2Latency: u32,
    pub D3Latency: u32,
}
impl Copy for DEVICE_CAPABILITIES {}
impl Clone for DEVICE_CAPABILITIES {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct DEVICE_OBJECT {
    pub Type: i16,
    pub Size: u16,
    pub ReferenceCount: i32,
    pub DriverObject: *mut DRIVER_OBJECT,
    pub NextDevice: *mut DEVICE_OBJECT,
    pub AttachedDevice: *mut DEVICE_OBJECT,
    pub CurrentIrp: *mut IRP,
    pub Timer: PIO_TIMER,
    pub Flags: u32,
    pub Characteristics: u32,
    pub Vpb: *mut VPB,
    pub DeviceExtension: *mut core::ffi::c_void,
    pub DeviceType: u32,
    pub StackSize: i8,
    pub Queue: DEVICE_OBJECT_0,
    pub AlignmentRequirement: u32,
    pub DeviceQueue: KDEVICE_QUEUE,
    pub Dpc: KDPC,
    pub ActiveThreadCount: u32,
    pub SecurityDescriptor: PSECURITY_DESCRIPTOR,
    pub DeviceLock: KEVENT,
    pub SectorSize: u16,
    pub Spare1: u16,
    pub DeviceObjectExtension: *mut DEVOBJ_EXTENSION,
    pub Reserved: *mut core::ffi::c_void,
}
impl Copy for DEVICE_OBJECT {}
impl Clone for DEVICE_OBJECT {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub union DEVICE_OBJECT_0 {
    pub ListEntry: LIST_ENTRY,
    pub Wcb: WAIT_CONTEXT_BLOCK,
}
impl Copy for DEVICE_OBJECT_0 {}
impl Clone for DEVICE_OBJECT_0 {
    fn clone(&self) -> Self {
        *self
    }
}
pub type DEVICE_POWER_STATE = i32;
pub type DEVICE_RELATION_TYPE = i32;
pub type DEVICE_TEXT_TYPE = i32;
pub type DEVICE_USAGE_NOTIFICATION_TYPE = i32;
#[repr(C)]
pub struct DEVOBJ_EXTENSION {
    pub Type: i16,
    pub Size: u16,
    pub DeviceObject: *mut DEVICE_OBJECT,
    pub PowerFlags: u32,
    pub Dope: *mut _DEVICE_OBJECT_POWER_EXTENSION,
    pub ExtensionFlags: u32,
    pub DeviceNode: *mut core::ffi::c_void,
    pub AttachedTo: *mut DEVICE_OBJECT,
    pub StartIoCount: i32,
    pub StartIoKey: i32,
    pub StartIoFlags: u32,
    pub Vpb: *mut VPB,
    pub DependencyNode: *mut core::ffi::c_void,
    pub InterruptContext: *mut core::ffi::c_void,
    pub InterruptCount: i32,
    pub VerifierContext: *mut core::ffi::c_void,
}
impl Copy for DEVOBJ_EXTENSION {}
impl Clone for DEVOBJ_EXTENSION {
    fn clone(&self) -> Self {
        *self
    }
}
pub type DIRECTORY_NOTIFY_INFORMATION_CLASS = i32;
#[repr(C)]
pub struct DISPATCHER_HEADER {
    pub Anonymous: DISPATCHER_HEADER_0,
    pub SignalState: i32,
    pub WaitListHead: LIST_ENTRY,
}
impl Copy for DISPATCHER_HEADER {}
impl Clone for DISPATCHER_HEADER {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub union DISPATCHER_HEADER_0 {
    pub Anonymous1: DISPATCHER_HEADER_0_0,
    pub Anonymous2: DISPATCHER_HEADER_0_1,
    pub Anonymous3: DISPATCHER_HEADER_0_2,
    pub Anonymous4: DISPATCHER_HEADER_0_3,
    pub Anonymous5: DISPATCHER_HEADER_0_4,
    pub Anonymous6: DISPATCHER_HEADER_0_5,
    pub Anonymous7: DISPATCHER_HEADER_0_6,
}
impl Copy for DISPATCHER_HEADER_0 {}
impl Clone for DISPATCHER_HEADER_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub union DISPATCHER_HEADER_0_0 {
    pub Lock: i32,
    pub LockNV: i32,
}
impl Copy for DISPATCHER_HEADER_0_0 {}
impl Clone for DISPATCHER_HEADER_0_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct DISPATCHER_HEADER_0_1 {
    pub Type: u8,
    pub Signalling: u8,
    pub Size: u8,
    pub Reserved1: u8,
}
impl Copy for DISPATCHER_HEADER_0_1 {}
impl Clone for DISPATCHER_HEADER_0_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct DISPATCHER_HEADER_0_2 {
    pub TimerType: u8,
    pub Anonymous1: DISPATCHER_HEADER_0_2_0,
    pub Hand: u8,
    pub Anonymous2: DISPATCHER_HEADER_0_2_1,
}
impl Copy for DISPATCHER_HEADER_0_2 {}
impl Clone for DISPATCHER_HEADER_0_2 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub union DISPATCHER_HEADER_0_2_0 {
    pub TimerControlFlags: u8,
    pub Anonymous: DISPATCHER_HEADER_0_2_0_0,
}
impl Copy for DISPATCHER_HEADER_0_2_0 {}
impl Clone for DISPATCHER_HEADER_0_2_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct DISPATCHER_HEADER_0_2_0_0 {
    pub _bitfield: u8,
}
impl Copy for DISPATCHER_HEADER_0_2_0_0 {}
impl Clone for DISPATCHER_HEADER_0_2_0_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub union DISPATCHER_HEADER_0_2_1 {
    pub TimerMiscFlags: u8,
    pub Anonymous: DISPATCHER_HEADER_0_2_1_0,
}
impl Copy for DISPATCHER_HEADER_0_2_1 {}
impl Clone for DISPATCHER_HEADER_0_2_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct DISPATCHER_HEADER_0_2_1_0 {
    pub _bitfield: u8,
}
impl Copy for DISPATCHER_HEADER_0_2_1_0 {}
impl Clone for DISPATCHER_HEADER_0_2_1_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct DISPATCHER_HEADER_0_3 {
    pub Timer2Type: u8,
    pub Anonymous: DISPATCHER_HEADER_0_3_0,
    pub Timer2ComponentId: u8,
    pub Timer2RelativeId: u8,
}
impl Copy for DISPATCHER_HEADER_0_3 {}
impl Clone for DISPATCHER_HEADER_0_3 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub union DISPATCHER_HEADER_0_3_0 {
    pub Timer2Flags: u8,
    pub Anonymous: DISPATCHER_HEADER_0_3_0_0,
}
impl Copy for DISPATCHER_HEADER_0_3_0 {}
impl Clone for DISPATCHER_HEADER_0_3_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct DISPATCHER_HEADER_0_3_0_0 {
    pub _bitfield: u8,
}
impl Copy for DISPATCHER_HEADER_0_3_0_0 {}
impl Clone for DISPATCHER_HEADER_0_3_0_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct DISPATCHER_HEADER_0_4 {
    pub QueueType: u8,
    pub Anonymous: DISPATCHER_HEADER_0_4_0,
    pub QueueSize: u8,
    pub QueueReserved: u8,
}
impl Copy for DISPATCHER_HEADER_0_4 {}
impl Clone for DISPATCHER_HEADER_0_4 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub union DISPATCHER_HEADER_0_4_0 {
    pub QueueControlFlags: u8,
    pub Anonymous: DISPATCHER_HEADER_0_4_0_0,
}
impl Copy for DISPATCHER_HEADER_0_4_0 {}
impl Clone for DISPATCHER_HEADER_0_4_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct DISPATCHER_HEADER_0_4_0_0 {
    pub _bitfield: u8,
}
impl Copy for DISPATCHER_HEADER_0_4_0_0 {}
impl Clone for DISPATCHER_HEADER_0_4_0_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct DISPATCHER_HEADER_0_5 {
    pub ThreadType: u8,
    pub ThreadReserved: u8,
    pub Anonymous1: DISPATCHER_HEADER_0_5_0,
    pub Anonymous2: DISPATCHER_HEADER_0_5_1,
}
impl Copy for DISPATCHER_HEADER_0_5 {}
impl Clone for DISPATCHER_HEADER_0_5 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub union DISPATCHER_HEADER_0_5_0 {
    pub ThreadControlFlags: u8,
    pub Anonymous: DISPATCHER_HEADER_0_5_0_0,
}
impl Copy for DISPATCHER_HEADER_0_5_0 {}
impl Clone for DISPATCHER_HEADER_0_5_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct DISPATCHER_HEADER_0_5_0_0 {
    pub _bitfield: u8,
}
impl Copy for DISPATCHER_HEADER_0_5_0_0 {}
impl Clone for DISPATCHER_HEADER_0_5_0_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub union DISPATCHER_HEADER_0_5_1 {
    pub DebugActive: u8,
}
impl Copy for DISPATCHER_HEADER_0_5_1 {}
impl Clone for DISPATCHER_HEADER_0_5_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct DISPATCHER_HEADER_0_6 {
    pub MutantType: u8,
    pub MutantSize: u8,
    pub DpcActive: BOOLEAN,
    pub MutantReserved: u8,
}
impl Copy for DISPATCHER_HEADER_0_6 {}
impl Clone for DISPATCHER_HEADER_0_6 {
    fn clone(&self) -> Self {
        *self
    }
}
pub type DRIVER_ADD_DEVICE = Option<
    unsafe extern "system" fn(
        driverobject: *const DRIVER_OBJECT,
        physicaldeviceobject: *const DEVICE_OBJECT,
    ) -> NTSTATUS,
>;
pub type DRIVER_CANCEL =
    Option<unsafe extern "system" fn(deviceobject: *mut DEVICE_OBJECT, irp: *mut IRP)>;
pub type DRIVER_CONTROL = Option<
    unsafe extern "system" fn(
        deviceobject: *const DEVICE_OBJECT,
        irp: *mut IRP,
        mapregisterbase: *const core::ffi::c_void,
        context: *const core::ffi::c_void,
    ) -> IO_ALLOCATION_ACTION,
>;
pub type DRIVER_DISPATCH = Option<
    unsafe extern "system" fn(deviceobject: *const DEVICE_OBJECT, irp: *mut IRP) -> NTSTATUS,
>;
#[repr(C)]
pub struct DRIVER_EXTENSION {
    pub DriverObject: *mut DRIVER_OBJECT,
    pub AddDevice: *mut DRIVER_ADD_DEVICE,
    pub Count: u32,
    pub ServiceKeyName: UNICODE_STRING,
}
impl Copy for DRIVER_EXTENSION {}
impl Clone for DRIVER_EXTENSION {
    fn clone(&self) -> Self {
        *self
    }
}
pub type DRIVER_INITIALIZE = Option<
    unsafe extern "system" fn(
        driverobject: *const DRIVER_OBJECT,
        registrypath: *const UNICODE_STRING,
    ) -> NTSTATUS,
>;
#[repr(C)]
pub struct DRIVER_OBJECT {
    pub Type: i16,
    pub Size: i16,
    pub DeviceObject: *mut DEVICE_OBJECT,
    pub Flags: u32,
    pub DriverStart: *mut core::ffi::c_void,
    pub DriverSize: u32,
    pub DriverSection: *mut core::ffi::c_void,
    pub DriverExtension: *mut DRIVER_EXTENSION,
    pub DriverName: UNICODE_STRING,
    pub HardwareDatabase: *mut UNICODE_STRING,
    pub FastIoDispatch: *mut FAST_IO_DISPATCH,
    pub DriverInit: *mut DRIVER_INITIALIZE,
    pub DriverStartIo: *mut DRIVER_STARTIO,
    pub DriverUnload: *mut DRIVER_UNLOAD,
    pub MajorFunction: [*mut DRIVER_DISPATCH; 28],
}
impl Copy for DRIVER_OBJECT {}
impl Clone for DRIVER_OBJECT {
    fn clone(&self) -> Self {
        *self
    }
}
pub type DRIVER_STARTIO =
    Option<unsafe extern "system" fn(deviceobject: *mut DEVICE_OBJECT, irp: *mut IRP)>;
pub type DRIVER_UNLOAD = Option<unsafe extern "system" fn(driverobject: *const DRIVER_OBJECT)>;
#[repr(C)]
pub struct ERESOURCE {
    pub SystemResourcesList: LIST_ENTRY,
    pub OwnerTable: *mut OWNER_ENTRY,
    pub ActiveCount: i16,
    pub Anonymous1: ERESOURCE_0,
    pub SharedWaiters: *mut core::ffi::c_void,
    pub ExclusiveWaiters: *mut core::ffi::c_void,
    pub OwnerEntry: OWNER_ENTRY,
    pub ActiveEntries: u32,
    pub ContentionCount: u32,
    pub NumberOfSharedWaiters: u32,
    pub NumberOfExclusiveWaiters: u32,
    pub Anonymous2: ERESOURCE_1,
    pub SpinLock: usize,
}
impl Copy for ERESOURCE {}
impl Clone for ERESOURCE {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub union ERESOURCE_0 {
    pub Flag: u16,
    pub Anonymous: ERESOURCE_0_0,
}
impl Copy for ERESOURCE_0 {}
impl Clone for ERESOURCE_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct ERESOURCE_0_0 {
    pub ReservedLowFlags: u8,
    pub WaiterPriority: u8,
}
impl Copy for ERESOURCE_0_0 {}
impl Clone for ERESOURCE_0_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub union ERESOURCE_1 {
    pub Address: *mut core::ffi::c_void,
    pub CreatorBackTraceIndex: usize,
}
impl Copy for ERESOURCE_1 {}
impl Clone for ERESOURCE_1 {
    fn clone(&self) -> Self {
        *self
    }
}
pub type FAST_IO_ACQUIRE_FILE = Option<unsafe extern "system" fn(fileobject: *const FILE_OBJECT)>;
pub type FAST_IO_ACQUIRE_FOR_CCFLUSH = Option<
    unsafe extern "system" fn(
        fileobject: *const FILE_OBJECT,
        deviceobject: *const DEVICE_OBJECT,
    ) -> NTSTATUS,
>;
pub type FAST_IO_ACQUIRE_FOR_MOD_WRITE = Option<
    unsafe extern "system" fn(
        fileobject: *const FILE_OBJECT,
        endingoffset: *const i64,
        resourcetorelease: *mut *mut ERESOURCE,
        deviceobject: *const DEVICE_OBJECT,
    ) -> NTSTATUS,
>;
pub type FAST_IO_CHECK_IF_POSSIBLE = Option<
    unsafe extern "system" fn(
        fileobject: *const FILE_OBJECT,
        fileoffset: *const i64,
        length: u32,
        wait: BOOLEAN,
        lockkey: u32,
        checkforreadoperation: BOOLEAN,
        iostatus: *mut IO_STATUS_BLOCK,
        deviceobject: *const DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type FAST_IO_DETACH_DEVICE = Option<
    unsafe extern "system" fn(
        sourcedevice: *const DEVICE_OBJECT,
        targetdevice: *const DEVICE_OBJECT,
    ),
>;
pub type FAST_IO_DEVICE_CONTROL = Option<
    unsafe extern "system" fn(
        fileobject: *const FILE_OBJECT,
        wait: BOOLEAN,
        inputbuffer: *const core::ffi::c_void,
        inputbufferlength: u32,
        outputbuffer: *mut core::ffi::c_void,
        outputbufferlength: u32,
        iocontrolcode: u32,
        iostatus: *mut IO_STATUS_BLOCK,
        deviceobject: *const DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
#[repr(C)]
pub struct FAST_IO_DISPATCH {
    pub SizeOfFastIoDispatch: u32,
    pub FastIoCheckIfPossible: *mut FAST_IO_CHECK_IF_POSSIBLE,
    pub FastIoRead: *mut FAST_IO_READ,
    pub FastIoWrite: *mut FAST_IO_WRITE,
    pub FastIoQueryBasicInfo: *mut FAST_IO_QUERY_BASIC_INFO,
    pub FastIoQueryStandardInfo: *mut FAST_IO_QUERY_STANDARD_INFO,
    pub FastIoLock: *mut FAST_IO_LOCK,
    pub FastIoUnlockSingle: *mut FAST_IO_UNLOCK_SINGLE,
    pub FastIoUnlockAll: *mut FAST_IO_UNLOCK_ALL,
    pub FastIoUnlockAllByKey: *mut FAST_IO_UNLOCK_ALL_BY_KEY,
    pub FastIoDeviceControl: *mut FAST_IO_DEVICE_CONTROL,
    pub AcquireFileForNtCreateSection: *mut FAST_IO_ACQUIRE_FILE,
    pub ReleaseFileForNtCreateSection: *mut FAST_IO_RELEASE_FILE,
    pub FastIoDetachDevice: *mut FAST_IO_DETACH_DEVICE,
    pub FastIoQueryNetworkOpenInfo: *mut FAST_IO_QUERY_NETWORK_OPEN_INFO,
    pub AcquireForModWrite: *mut FAST_IO_ACQUIRE_FOR_MOD_WRITE,
    pub MdlRead: *mut FAST_IO_MDL_READ,
    pub MdlReadComplete: *mut FAST_IO_MDL_READ_COMPLETE,
    pub PrepareMdlWrite: *mut FAST_IO_PREPARE_MDL_WRITE,
    pub MdlWriteComplete: *mut FAST_IO_MDL_WRITE_COMPLETE,
    pub FastIoReadCompressed: *mut FAST_IO_READ_COMPRESSED,
    pub FastIoWriteCompressed: *mut FAST_IO_WRITE_COMPRESSED,
    pub MdlReadCompleteCompressed: *mut FAST_IO_MDL_READ_COMPLETE_COMPRESSED,
    pub MdlWriteCompleteCompressed: *mut FAST_IO_MDL_WRITE_COMPLETE_COMPRESSED,
    pub FastIoQueryOpen: *mut FAST_IO_QUERY_OPEN,
    pub ReleaseForModWrite: *mut FAST_IO_RELEASE_FOR_MOD_WRITE,
    pub AcquireForCcFlush: *mut FAST_IO_ACQUIRE_FOR_CCFLUSH,
    pub ReleaseForCcFlush: *mut FAST_IO_RELEASE_FOR_CCFLUSH,
}
impl Copy for FAST_IO_DISPATCH {}
impl Clone for FAST_IO_DISPATCH {
    fn clone(&self) -> Self {
        *self
    }
}
pub type FAST_IO_LOCK = Option<
    unsafe extern "system" fn(
        fileobject: *const FILE_OBJECT,
        fileoffset: *const i64,
        length: *const i64,
        processid: PEPROCESS,
        key: u32,
        failimmediately: BOOLEAN,
        exclusivelock: BOOLEAN,
        iostatus: *mut IO_STATUS_BLOCK,
        deviceobject: *const DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type FAST_IO_MDL_READ = Option<
    unsafe extern "system" fn(
        fileobject: *const FILE_OBJECT,
        fileoffset: *const i64,
        length: u32,
        lockkey: u32,
        mdlchain: *mut *mut MDL,
        iostatus: *mut IO_STATUS_BLOCK,
        deviceobject: *const DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type FAST_IO_MDL_READ_COMPLETE = Option<
    unsafe extern "system" fn(
        fileobject: *const FILE_OBJECT,
        mdlchain: *const MDL,
        deviceobject: *const DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type FAST_IO_MDL_READ_COMPLETE_COMPRESSED = Option<
    unsafe extern "system" fn(
        fileobject: *const FILE_OBJECT,
        mdlchain: *const MDL,
        deviceobject: *const DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type FAST_IO_MDL_WRITE_COMPLETE = Option<
    unsafe extern "system" fn(
        fileobject: *const FILE_OBJECT,
        fileoffset: *const i64,
        mdlchain: *const MDL,
        deviceobject: *const DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type FAST_IO_MDL_WRITE_COMPLETE_COMPRESSED = Option<
    unsafe extern "system" fn(
        fileobject: *const FILE_OBJECT,
        fileoffset: *const i64,
        mdlchain: *const MDL,
        deviceobject: *const DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type FAST_IO_PREPARE_MDL_WRITE = Option<
    unsafe extern "system" fn(
        fileobject: *const FILE_OBJECT,
        fileoffset: *const i64,
        length: u32,
        lockkey: u32,
        mdlchain: *mut *mut MDL,
        iostatus: *mut IO_STATUS_BLOCK,
        deviceobject: *const DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type FAST_IO_QUERY_BASIC_INFO = Option<
    unsafe extern "system" fn(
        fileobject: *const FILE_OBJECT,
        wait: BOOLEAN,
        buffer: *mut FILE_BASIC_INFORMATION,
        iostatus: *mut IO_STATUS_BLOCK,
        deviceobject: *const DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type FAST_IO_QUERY_NETWORK_OPEN_INFO = Option<
    unsafe extern "system" fn(
        fileobject: *const FILE_OBJECT,
        wait: BOOLEAN,
        buffer: *mut FILE_NETWORK_OPEN_INFORMATION,
        iostatus: *mut IO_STATUS_BLOCK,
        deviceobject: *const DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type FAST_IO_QUERY_OPEN = Option<
    unsafe extern "system" fn(
        irp: *mut IRP,
        networkinformation: *mut FILE_NETWORK_OPEN_INFORMATION,
        deviceobject: *const DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type FAST_IO_QUERY_STANDARD_INFO = Option<
    unsafe extern "system" fn(
        fileobject: *const FILE_OBJECT,
        wait: BOOLEAN,
        buffer: *mut FILE_STANDARD_INFORMATION,
        iostatus: *mut IO_STATUS_BLOCK,
        deviceobject: *const DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type FAST_IO_READ = Option<
    unsafe extern "system" fn(
        fileobject: *const FILE_OBJECT,
        fileoffset: *const i64,
        length: u32,
        wait: BOOLEAN,
        lockkey: u32,
        buffer: *mut core::ffi::c_void,
        iostatus: *mut IO_STATUS_BLOCK,
        deviceobject: *const DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type FAST_IO_READ_COMPRESSED = Option<
    unsafe extern "system" fn(
        fileobject: *const FILE_OBJECT,
        fileoffset: *const i64,
        length: u32,
        lockkey: u32,
        buffer: *mut core::ffi::c_void,
        mdlchain: *mut *mut MDL,
        iostatus: *mut IO_STATUS_BLOCK,
        compresseddatainfo: *mut COMPRESSED_DATA_INFO,
        compresseddatainfolength: u32,
        deviceobject: *const DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type FAST_IO_RELEASE_FILE = Option<unsafe extern "system" fn(fileobject: *const FILE_OBJECT)>;
pub type FAST_IO_RELEASE_FOR_CCFLUSH = Option<
    unsafe extern "system" fn(
        fileobject: *const FILE_OBJECT,
        deviceobject: *const DEVICE_OBJECT,
    ) -> NTSTATUS,
>;
pub type FAST_IO_RELEASE_FOR_MOD_WRITE = Option<
    unsafe extern "system" fn(
        fileobject: *const FILE_OBJECT,
        resourcetorelease: *const ERESOURCE,
        deviceobject: *const DEVICE_OBJECT,
    ) -> NTSTATUS,
>;
pub type FAST_IO_UNLOCK_ALL = Option<
    unsafe extern "system" fn(
        fileobject: *const FILE_OBJECT,
        processid: PEPROCESS,
        iostatus: *mut IO_STATUS_BLOCK,
        deviceobject: *const DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type FAST_IO_UNLOCK_ALL_BY_KEY = Option<
    unsafe extern "system" fn(
        fileobject: *const FILE_OBJECT,
        processid: *const core::ffi::c_void,
        key: u32,
        iostatus: *mut IO_STATUS_BLOCK,
        deviceobject: *const DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type FAST_IO_UNLOCK_SINGLE = Option<
    unsafe extern "system" fn(
        fileobject: *const FILE_OBJECT,
        fileoffset: *const i64,
        length: *const i64,
        processid: PEPROCESS,
        key: u32,
        iostatus: *mut IO_STATUS_BLOCK,
        deviceobject: *const DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type FAST_IO_WRITE = Option<
    unsafe extern "system" fn(
        fileobject: *const FILE_OBJECT,
        fileoffset: *const i64,
        length: u32,
        wait: BOOLEAN,
        lockkey: u32,
        buffer: *const core::ffi::c_void,
        iostatus: *mut IO_STATUS_BLOCK,
        deviceobject: *const DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type FAST_IO_WRITE_COMPRESSED = Option<
    unsafe extern "system" fn(
        fileobject: *const FILE_OBJECT,
        fileoffset: *const i64,
        length: u32,
        lockkey: u32,
        buffer: *const core::ffi::c_void,
        mdlchain: *mut *mut MDL,
        iostatus: *mut IO_STATUS_BLOCK,
        compresseddatainfo: *const COMPRESSED_DATA_INFO,
        compresseddatainfolength: u32,
        deviceobject: *const DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
#[repr(C)]
pub struct FILE_BASIC_INFORMATION {
    pub CreationTime: i64,
    pub LastAccessTime: i64,
    pub LastWriteTime: i64,
    pub ChangeTime: i64,
    pub FileAttributes: u32,
}
impl Copy for FILE_BASIC_INFORMATION {}
impl Clone for FILE_BASIC_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FILE_GET_QUOTA_INFORMATION {
    pub NextEntryOffset: u32,
    pub SidLength: u32,
    pub Sid: SID,
}
impl Copy for FILE_GET_QUOTA_INFORMATION {}
impl Clone for FILE_GET_QUOTA_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
pub type FILE_INFORMATION_CLASS = i32;
#[repr(C)]
pub struct FILE_NAMES_INFORMATION {
    pub NextEntryOffset: u32,
    pub FileIndex: u32,
    pub FileNameLength: u32,
    pub FileName: [u16; 1],
}
impl Copy for FILE_NAMES_INFORMATION {}
impl Clone for FILE_NAMES_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FILE_NETWORK_OPEN_INFORMATION {
    pub CreationTime: i64,
    pub LastAccessTime: i64,
    pub LastWriteTime: i64,
    pub ChangeTime: i64,
    pub AllocationSize: i64,
    pub EndOfFile: i64,
    pub FileAttributes: u32,
}
impl Copy for FILE_NETWORK_OPEN_INFORMATION {}
impl Clone for FILE_NETWORK_OPEN_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FILE_OBJECT {
    pub Type: i16,
    pub Size: i16,
    pub DeviceObject: *mut DEVICE_OBJECT,
    pub Vpb: *mut VPB,
    pub FsContext: *mut core::ffi::c_void,
    pub FsContext2: *mut core::ffi::c_void,
    pub SectionObjectPointer: *mut SECTION_OBJECT_POINTERS,
    pub PrivateCacheMap: *mut core::ffi::c_void,
    pub FinalStatus: NTSTATUS,
    pub RelatedFileObject: *mut FILE_OBJECT,
    pub LockOperation: BOOLEAN,
    pub DeletePending: BOOLEAN,
    pub ReadAccess: BOOLEAN,
    pub WriteAccess: BOOLEAN,
    pub DeleteAccess: BOOLEAN,
    pub SharedRead: BOOLEAN,
    pub SharedWrite: BOOLEAN,
    pub SharedDelete: BOOLEAN,
    pub Flags: u32,
    pub FileName: UNICODE_STRING,
    pub CurrentByteOffset: i64,
    pub Waiters: u32,
    pub Busy: u32,
    pub LastLock: *mut core::ffi::c_void,
    pub Lock: KEVENT,
    pub Event: KEVENT,
    pub CompletionContext: *mut IO_COMPLETION_CONTEXT,
    pub IrpListLock: usize,
    pub IrpList: LIST_ENTRY,
    pub FileObjectExtension: *mut core::ffi::c_void,
}
impl Copy for FILE_OBJECT {}
impl Clone for FILE_OBJECT {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FILE_STANDARD_INFORMATION {
    pub AllocationSize: i64,
    pub EndOfFile: i64,
    pub NumberOfLinks: u32,
    pub DeletePending: BOOLEAN,
    pub Directory: BOOLEAN,
}
impl Copy for FILE_STANDARD_INFORMATION {}
impl Clone for FILE_STANDARD_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_CALLBACK_DATA {
    pub Flags: u32,
    pub Thread: PETHREAD,
    pub Iopb: *const FLT_IO_PARAMETER_BLOCK,
    pub IoStatus: IO_STATUS_BLOCK,
    pub TagData: *mut FLT_TAG_DATA_BUFFER,
    pub Anonymous: FLT_CALLBACK_DATA_0,
    pub RequestorMode: i8,
}
impl Copy for FLT_CALLBACK_DATA {}
impl Clone for FLT_CALLBACK_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub union FLT_CALLBACK_DATA_0 {
    pub Anonymous: FLT_CALLBACK_DATA_0_0,
    pub FilterContext: [*mut core::ffi::c_void; 4],
}
impl Copy for FLT_CALLBACK_DATA_0 {}
impl Clone for FLT_CALLBACK_DATA_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_CALLBACK_DATA_0_0 {
    pub QueueLinks: LIST_ENTRY,
    pub QueueContext: [*mut core::ffi::c_void; 2],
}
impl Copy for FLT_CALLBACK_DATA_0_0 {}
impl Clone for FLT_CALLBACK_DATA_0_0 {
    fn clone(&self) -> Self {
        *self
    }
}
pub const FLT_CONTEXT_END: u32 = 65535u32;
#[repr(C)]
pub struct FLT_CONTEXT_REGISTRATION {
    pub ContextType: u16,
    pub Flags: u16,
    pub ContextCleanupCallback: PFLT_CONTEXT_CLEANUP_CALLBACK,
    pub Size: usize,
    pub PoolTag: u32,
    pub ContextAllocateCallback: PFLT_CONTEXT_ALLOCATE_CALLBACK,
    pub ContextFreeCallback: PFLT_CONTEXT_FREE_CALLBACK,
    pub Reserved1: *mut core::ffi::c_void,
}
impl Copy for FLT_CONTEXT_REGISTRATION {}
impl Clone for FLT_CONTEXT_REGISTRATION {
    fn clone(&self) -> Self {
        *self
    }
}
pub type FLT_FILESYSTEM_TYPE = i32;
#[repr(C)]
pub struct FLT_FILE_NAME_INFORMATION {
    pub Size: u16,
    pub NamesParsed: u16,
    pub Format: u32,
    pub Name: UNICODE_STRING,
    pub Volume: UNICODE_STRING,
    pub Share: UNICODE_STRING,
    pub Extension: UNICODE_STRING,
    pub Stream: UNICODE_STRING,
    pub FinalComponent: UNICODE_STRING,
    pub ParentDir: UNICODE_STRING,
}
impl Copy for FLT_FILE_NAME_INFORMATION {}
impl Clone for FLT_FILE_NAME_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
pub const FLT_FILE_NAME_NORMALIZED: u32 = 1u32;
pub const FLT_FILE_NAME_QUERY_DEFAULT: u32 = 256u32;
#[repr(C)]
pub struct FLT_IO_PARAMETER_BLOCK {
    pub IrpFlags: u32,
    pub MajorFunction: u8,
    pub MinorFunction: u8,
    pub OperationFlags: u8,
    pub Reserved: u8,
    pub TargetFileObject: *mut FILE_OBJECT,
    pub TargetInstance: PFLT_INSTANCE,
    pub Parameters: FLT_PARAMETERS,
}
impl Copy for FLT_IO_PARAMETER_BLOCK {}
impl Clone for FLT_IO_PARAMETER_BLOCK {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_NAME_CONTROL {
    pub Name: UNICODE_STRING,
}
impl Copy for FLT_NAME_CONTROL {}
impl Clone for FLT_NAME_CONTROL {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_OPERATION_REGISTRATION {
    pub MajorFunction: u8,
    pub Flags: u32,
    pub PreOperation: PFLT_PRE_OPERATION_CALLBACK,
    pub PostOperation: PFLT_POST_OPERATION_CALLBACK,
    pub Reserved1: *mut core::ffi::c_void,
}
impl Copy for FLT_OPERATION_REGISTRATION {}
impl Clone for FLT_OPERATION_REGISTRATION {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub union FLT_PARAMETERS {
    pub Create: FLT_PARAMETERS_4,
    pub CreatePipe: FLT_PARAMETERS_3,
    pub CreateMailslot: FLT_PARAMETERS_2,
    pub Read: FLT_PARAMETERS_24,
    pub Write: FLT_PARAMETERS_32,
    pub QueryFileInformation: FLT_PARAMETERS_19,
    pub SetFileInformation: FLT_PARAMETERS_27,
    pub QueryEa: FLT_PARAMETERS_18,
    pub SetEa: FLT_PARAMETERS_26,
    pub QueryVolumeInformation: FLT_PARAMETERS_23,
    pub SetVolumeInformation: FLT_PARAMETERS_30,
    pub DirectoryControl: FLT_PARAMETERS_6,
    pub FileSystemControl: FLT_PARAMETERS_8,
    pub DeviceIoControl: FLT_PARAMETERS_5,
    pub LockControl: FLT_PARAMETERS_9,
    pub QuerySecurity: FLT_PARAMETERS_22,
    pub SetSecurity: FLT_PARAMETERS_29,
    pub WMI: FLT_PARAMETERS_31,
    pub QueryQuota: FLT_PARAMETERS_21,
    pub SetQuota: FLT_PARAMETERS_28,
    pub Pnp: FLT_PARAMETERS_16,
    pub AcquireForSectionSynchronization: FLT_PARAMETERS_1,
    pub AcquireForModifiedPageWriter: FLT_PARAMETERS_0,
    pub ReleaseForModifiedPageWriter: FLT_PARAMETERS_25,
    pub QueryOpen: FLT_PARAMETERS_20,
    pub FastIoCheckIfPossible: FLT_PARAMETERS_7,
    pub NetworkQueryOpen: FLT_PARAMETERS_14,
    pub MdlRead: FLT_PARAMETERS_11,
    pub MdlReadComplete: FLT_PARAMETERS_10,
    pub PrepareMdlWrite: FLT_PARAMETERS_17,
    pub MdlWriteComplete: FLT_PARAMETERS_12,
    pub MountVolume: FLT_PARAMETERS_13,
    pub Others: FLT_PARAMETERS_15,
}
impl Copy for FLT_PARAMETERS {}
impl Clone for FLT_PARAMETERS {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_0 {
    pub EndingOffset: *mut i64,
    pub ResourceToRelease: *mut *mut ERESOURCE,
}
impl Copy for FLT_PARAMETERS_0 {}
impl Clone for FLT_PARAMETERS_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_1 {
    pub SyncType: FS_FILTER_SECTION_SYNC_TYPE,
    pub PageProtection: u32,
    pub OutputInformation: *mut FS_FILTER_SECTION_SYNC_OUTPUT,
    pub Flags: u32,
    pub AllocationAttributes: u32,
}
impl Copy for FLT_PARAMETERS_1 {}
impl Clone for FLT_PARAMETERS_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_2 {
    pub SecurityContext: *mut IO_SECURITY_CONTEXT,
    pub Options: u32,
    pub Reserved: u16,
    pub ShareAccess: u16,
    pub Parameters: *mut core::ffi::c_void,
}
impl Copy for FLT_PARAMETERS_2 {}
impl Clone for FLT_PARAMETERS_2 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_3 {
    pub SecurityContext: *mut IO_SECURITY_CONTEXT,
    pub Options: u32,
    pub Reserved: u16,
    pub ShareAccess: u16,
    pub Parameters: *mut core::ffi::c_void,
}
impl Copy for FLT_PARAMETERS_3 {}
impl Clone for FLT_PARAMETERS_3 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C, packed(4))]
pub struct FLT_PARAMETERS_4 {
    pub SecurityContext: *mut IO_SECURITY_CONTEXT,
    pub Options: u32,
    pub FileAttributes: u16,
    pub ShareAccess: u16,
    pub EaLength: u32,
    pub EaBuffer: *mut core::ffi::c_void,
    pub AllocationSize: i64,
}
impl Copy for FLT_PARAMETERS_4 {}
impl Clone for FLT_PARAMETERS_4 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub union FLT_PARAMETERS_5 {
    pub Common: FLT_PARAMETERS_5_1,
    pub Neither: FLT_PARAMETERS_5_4,
    pub Buffered: FLT_PARAMETERS_5_0,
    pub Direct: FLT_PARAMETERS_5_2,
    pub FastIo: FLT_PARAMETERS_5_3,
}
impl Copy for FLT_PARAMETERS_5 {}
impl Clone for FLT_PARAMETERS_5 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_5_0 {
    pub OutputBufferLength: u32,
    pub InputBufferLength: u32,
    pub IoControlCode: u32,
    pub SystemBuffer: *mut core::ffi::c_void,
}
impl Copy for FLT_PARAMETERS_5_0 {}
impl Clone for FLT_PARAMETERS_5_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_5_1 {
    pub OutputBufferLength: u32,
    pub InputBufferLength: u32,
    pub IoControlCode: u32,
}
impl Copy for FLT_PARAMETERS_5_1 {}
impl Clone for FLT_PARAMETERS_5_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_5_2 {
    pub OutputBufferLength: u32,
    pub InputBufferLength: u32,
    pub IoControlCode: u32,
    pub InputSystemBuffer: *mut core::ffi::c_void,
    pub OutputBuffer: *mut core::ffi::c_void,
    pub OutputMdlAddress: *mut MDL,
}
impl Copy for FLT_PARAMETERS_5_2 {}
impl Clone for FLT_PARAMETERS_5_2 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_5_3 {
    pub OutputBufferLength: u32,
    pub InputBufferLength: u32,
    pub IoControlCode: u32,
    pub InputBuffer: *mut core::ffi::c_void,
    pub OutputBuffer: *mut core::ffi::c_void,
}
impl Copy for FLT_PARAMETERS_5_3 {}
impl Clone for FLT_PARAMETERS_5_3 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_5_4 {
    pub OutputBufferLength: u32,
    pub InputBufferLength: u32,
    pub IoControlCode: u32,
    pub InputBuffer: *mut core::ffi::c_void,
    pub OutputBuffer: *mut core::ffi::c_void,
    pub OutputMdlAddress: *mut MDL,
}
impl Copy for FLT_PARAMETERS_5_4 {}
impl Clone for FLT_PARAMETERS_5_4 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub union FLT_PARAMETERS_6 {
    pub QueryDirectory: FLT_PARAMETERS_6_2,
    pub NotifyDirectory: FLT_PARAMETERS_6_1,
    pub NotifyDirectoryEx: FLT_PARAMETERS_6_0,
}
impl Copy for FLT_PARAMETERS_6 {}
impl Clone for FLT_PARAMETERS_6 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_6_0 {
    pub Length: u32,
    pub CompletionFilter: u32,
    pub DirectoryNotifyInformationClass: DIRECTORY_NOTIFY_INFORMATION_CLASS,
    pub Spare2: u32,
    pub DirectoryBuffer: *mut core::ffi::c_void,
    pub MdlAddress: *mut MDL,
}
impl Copy for FLT_PARAMETERS_6_0 {}
impl Clone for FLT_PARAMETERS_6_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_6_1 {
    pub Length: u32,
    pub CompletionFilter: u32,
    pub Spare1: u32,
    pub Spare2: u32,
    pub DirectoryBuffer: *mut core::ffi::c_void,
    pub MdlAddress: *mut MDL,
}
impl Copy for FLT_PARAMETERS_6_1 {}
impl Clone for FLT_PARAMETERS_6_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_6_2 {
    pub Length: u32,
    pub FileName: *mut UNICODE_STRING,
    pub FileInformationClass: FILE_INFORMATION_CLASS,
    pub FileIndex: u32,
    pub DirectoryBuffer: *mut core::ffi::c_void,
    pub MdlAddress: *mut MDL,
}
impl Copy for FLT_PARAMETERS_6_2 {}
impl Clone for FLT_PARAMETERS_6_2 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C, packed(4))]
pub struct FLT_PARAMETERS_7 {
    pub FileOffset: i64,
    pub Length: u32,
    pub LockKey: u32,
    pub CheckForReadOperation: BOOLEAN,
}
impl Copy for FLT_PARAMETERS_7 {}
impl Clone for FLT_PARAMETERS_7 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub union FLT_PARAMETERS_8 {
    pub VerifyVolume: FLT_PARAMETERS_8_4,
    pub Common: FLT_PARAMETERS_8_1,
    pub Neither: FLT_PARAMETERS_8_3,
    pub Buffered: FLT_PARAMETERS_8_0,
    pub Direct: FLT_PARAMETERS_8_2,
}
impl Copy for FLT_PARAMETERS_8 {}
impl Clone for FLT_PARAMETERS_8 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_8_0 {
    pub OutputBufferLength: u32,
    pub InputBufferLength: u32,
    pub FsControlCode: u32,
    pub SystemBuffer: *mut core::ffi::c_void,
}
impl Copy for FLT_PARAMETERS_8_0 {}
impl Clone for FLT_PARAMETERS_8_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_8_1 {
    pub OutputBufferLength: u32,
    pub InputBufferLength: u32,
    pub FsControlCode: u32,
}
impl Copy for FLT_PARAMETERS_8_1 {}
impl Clone for FLT_PARAMETERS_8_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_8_2 {
    pub OutputBufferLength: u32,
    pub InputBufferLength: u32,
    pub FsControlCode: u32,
    pub InputSystemBuffer: *mut core::ffi::c_void,
    pub OutputBuffer: *mut core::ffi::c_void,
    pub OutputMdlAddress: *mut MDL,
}
impl Copy for FLT_PARAMETERS_8_2 {}
impl Clone for FLT_PARAMETERS_8_2 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_8_3 {
    pub OutputBufferLength: u32,
    pub InputBufferLength: u32,
    pub FsControlCode: u32,
    pub InputBuffer: *mut core::ffi::c_void,
    pub OutputBuffer: *mut core::ffi::c_void,
    pub OutputMdlAddress: *mut MDL,
}
impl Copy for FLT_PARAMETERS_8_3 {}
impl Clone for FLT_PARAMETERS_8_3 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_8_4 {
    pub Vpb: *mut VPB,
    pub DeviceObject: *mut DEVICE_OBJECT,
}
impl Copy for FLT_PARAMETERS_8_4 {}
impl Clone for FLT_PARAMETERS_8_4 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C, packed(4))]
pub struct FLT_PARAMETERS_9 {
    pub Length: *mut i64,
    pub Key: u32,
    pub ByteOffset: i64,
    pub ProcessId: PEPROCESS,
    pub FailImmediately: BOOLEAN,
    pub ExclusiveLock: BOOLEAN,
}
impl Copy for FLT_PARAMETERS_9 {}
impl Clone for FLT_PARAMETERS_9 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_10 {
    pub MdlChain: *mut MDL,
}
impl Copy for FLT_PARAMETERS_10 {}
impl Clone for FLT_PARAMETERS_10 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C, packed(4))]
pub struct FLT_PARAMETERS_11 {
    pub FileOffset: i64,
    pub Length: u32,
    pub Key: u32,
    pub MdlChain: *mut *mut MDL,
}
impl Copy for FLT_PARAMETERS_11 {}
impl Clone for FLT_PARAMETERS_11 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C, packed(4))]
pub struct FLT_PARAMETERS_12 {
    pub FileOffset: i64,
    pub MdlChain: *mut MDL,
}
impl Copy for FLT_PARAMETERS_12 {}
impl Clone for FLT_PARAMETERS_12 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_13 {
    pub DeviceType: u32,
}
impl Copy for FLT_PARAMETERS_13 {}
impl Clone for FLT_PARAMETERS_13 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_14 {
    pub Irp: *mut IRP,
    pub NetworkInformation: *mut FILE_NETWORK_OPEN_INFORMATION,
}
impl Copy for FLT_PARAMETERS_14 {}
impl Clone for FLT_PARAMETERS_14 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C, packed(4))]
pub struct FLT_PARAMETERS_15 {
    pub Argument1: *mut core::ffi::c_void,
    pub Argument2: *mut core::ffi::c_void,
    pub Argument3: *mut core::ffi::c_void,
    pub Argument4: *mut core::ffi::c_void,
    pub Argument5: *mut core::ffi::c_void,
    pub Argument6: i64,
}
impl Copy for FLT_PARAMETERS_15 {}
impl Clone for FLT_PARAMETERS_15 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub union FLT_PARAMETERS_16 {
    pub StartDevice: FLT_PARAMETERS_16_8,
    pub QueryDeviceRelations: FLT_PARAMETERS_16_2,
    pub QueryInterface: FLT_PARAMETERS_16_5,
    pub DeviceCapabilities: FLT_PARAMETERS_16_0,
    pub FilterResourceRequirements: FLT_PARAMETERS_16_1,
    pub ReadWriteConfig: FLT_PARAMETERS_16_6,
    pub SetLock: FLT_PARAMETERS_16_7,
    pub QueryId: FLT_PARAMETERS_16_4,
    pub QueryDeviceText: FLT_PARAMETERS_16_3,
    pub UsageNotification: FLT_PARAMETERS_16_9,
}
impl Copy for FLT_PARAMETERS_16 {}
impl Clone for FLT_PARAMETERS_16 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_16_0 {
    pub Capabilities: *mut DEVICE_CAPABILITIES,
}
impl Copy for FLT_PARAMETERS_16_0 {}
impl Clone for FLT_PARAMETERS_16_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_16_1 {
    pub IoResourceRequirementList: *mut IO_RESOURCE_REQUIREMENTS_LIST,
}
impl Copy for FLT_PARAMETERS_16_1 {}
impl Clone for FLT_PARAMETERS_16_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_16_2 {
    pub Type: DEVICE_RELATION_TYPE,
}
impl Copy for FLT_PARAMETERS_16_2 {}
impl Clone for FLT_PARAMETERS_16_2 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_16_3 {
    pub DeviceTextType: DEVICE_TEXT_TYPE,
    pub LocaleId: u32,
}
impl Copy for FLT_PARAMETERS_16_3 {}
impl Clone for FLT_PARAMETERS_16_3 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_16_4 {
    pub IdType: BUS_QUERY_ID_TYPE,
}
impl Copy for FLT_PARAMETERS_16_4 {}
impl Clone for FLT_PARAMETERS_16_4 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_16_5 {
    pub InterfaceType: *const GUID,
    pub Size: u16,
    pub Version: u16,
    pub Interface: *mut INTERFACE,
    pub InterfaceSpecificData: *mut core::ffi::c_void,
}
impl Copy for FLT_PARAMETERS_16_5 {}
impl Clone for FLT_PARAMETERS_16_5 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_16_6 {
    pub WhichSpace: u32,
    pub Buffer: *mut core::ffi::c_void,
    pub Offset: u32,
    pub Length: u32,
}
impl Copy for FLT_PARAMETERS_16_6 {}
impl Clone for FLT_PARAMETERS_16_6 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_16_7 {
    pub Lock: BOOLEAN,
}
impl Copy for FLT_PARAMETERS_16_7 {}
impl Clone for FLT_PARAMETERS_16_7 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_16_8 {
    pub AllocatedResources: *mut CM_RESOURCE_LIST,
    pub AllocatedResourcesTranslated: *mut CM_RESOURCE_LIST,
}
impl Copy for FLT_PARAMETERS_16_8 {}
impl Clone for FLT_PARAMETERS_16_8 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_16_9 {
    pub InPath: BOOLEAN,
    pub Reserved: [BOOLEAN; 3],
    pub Type: DEVICE_USAGE_NOTIFICATION_TYPE,
}
impl Copy for FLT_PARAMETERS_16_9 {}
impl Clone for FLT_PARAMETERS_16_9 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C, packed(4))]
pub struct FLT_PARAMETERS_17 {
    pub FileOffset: i64,
    pub Length: u32,
    pub Key: u32,
    pub MdlChain: *mut *mut MDL,
}
impl Copy for FLT_PARAMETERS_17 {}
impl Clone for FLT_PARAMETERS_17 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_18 {
    pub Length: u32,
    pub EaList: *mut core::ffi::c_void,
    pub EaListLength: u32,
    pub EaIndex: u32,
    pub EaBuffer: *mut core::ffi::c_void,
    pub MdlAddress: *mut MDL,
}
impl Copy for FLT_PARAMETERS_18 {}
impl Clone for FLT_PARAMETERS_18 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_19 {
    pub Length: u32,
    pub FileInformationClass: FILE_INFORMATION_CLASS,
    pub InfoBuffer: *mut core::ffi::c_void,
}
impl Copy for FLT_PARAMETERS_19 {}
impl Clone for FLT_PARAMETERS_19 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_20 {
    pub Irp: *mut IRP,
    pub FileInformation: *mut core::ffi::c_void,
    pub Length: *mut u32,
    pub FileInformationClass: FILE_INFORMATION_CLASS,
}
impl Copy for FLT_PARAMETERS_20 {}
impl Clone for FLT_PARAMETERS_20 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_21 {
    pub Length: u32,
    pub StartSid: PSID,
    pub SidList: *mut FILE_GET_QUOTA_INFORMATION,
    pub SidListLength: u32,
    pub QuotaBuffer: *mut core::ffi::c_void,
    pub MdlAddress: *mut MDL,
}
impl Copy for FLT_PARAMETERS_21 {}
impl Clone for FLT_PARAMETERS_21 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_22 {
    pub SecurityInformation: u32,
    pub Length: u32,
    pub SecurityBuffer: *mut core::ffi::c_void,
    pub MdlAddress: *mut MDL,
}
impl Copy for FLT_PARAMETERS_22 {}
impl Clone for FLT_PARAMETERS_22 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_23 {
    pub Length: u32,
    pub FsInformationClass: FS_INFORMATION_CLASS,
    pub VolumeBuffer: *mut core::ffi::c_void,
}
impl Copy for FLT_PARAMETERS_23 {}
impl Clone for FLT_PARAMETERS_23 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C, packed(4))]
pub struct FLT_PARAMETERS_24 {
    pub Length: u32,
    pub Key: u32,
    pub ByteOffset: i64,
    pub ReadBuffer: *mut core::ffi::c_void,
    pub MdlAddress: *mut MDL,
}
impl Copy for FLT_PARAMETERS_24 {}
impl Clone for FLT_PARAMETERS_24 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_25 {
    pub ResourceToRelease: *mut ERESOURCE,
}
impl Copy for FLT_PARAMETERS_25 {}
impl Clone for FLT_PARAMETERS_25 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_26 {
    pub Length: u32,
    pub EaBuffer: *mut core::ffi::c_void,
    pub MdlAddress: *mut MDL,
}
impl Copy for FLT_PARAMETERS_26 {}
impl Clone for FLT_PARAMETERS_26 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_27 {
    pub Length: u32,
    pub FileInformationClass: FILE_INFORMATION_CLASS,
    pub ParentOfTarget: *mut FILE_OBJECT,
    pub Anonymous: FLT_PARAMETERS_27_0,
    pub InfoBuffer: *mut core::ffi::c_void,
}
impl Copy for FLT_PARAMETERS_27 {}
impl Clone for FLT_PARAMETERS_27 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub union FLT_PARAMETERS_27_0 {
    pub Anonymous: FLT_PARAMETERS_27_0_0,
    pub ClusterCount: u32,
    pub DeleteHandle: HANDLE,
}
impl Copy for FLT_PARAMETERS_27_0 {}
impl Clone for FLT_PARAMETERS_27_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_27_0_0 {
    pub ReplaceIfExists: BOOLEAN,
    pub AdvanceOnly: BOOLEAN,
}
impl Copy for FLT_PARAMETERS_27_0_0 {}
impl Clone for FLT_PARAMETERS_27_0_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_28 {
    pub Length: u32,
    pub QuotaBuffer: *mut core::ffi::c_void,
    pub MdlAddress: *mut MDL,
}
impl Copy for FLT_PARAMETERS_28 {}
impl Clone for FLT_PARAMETERS_28 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_29 {
    pub SecurityInformation: u32,
    pub SecurityDescriptor: PSECURITY_DESCRIPTOR,
}
impl Copy for FLT_PARAMETERS_29 {}
impl Clone for FLT_PARAMETERS_29 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_30 {
    pub Length: u32,
    pub FsInformationClass: FS_INFORMATION_CLASS,
    pub VolumeBuffer: *mut core::ffi::c_void,
}
impl Copy for FLT_PARAMETERS_30 {}
impl Clone for FLT_PARAMETERS_30 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_PARAMETERS_31 {
    pub ProviderId: usize,
    pub DataPath: *mut core::ffi::c_void,
    pub BufferSize: u32,
    pub Buffer: *mut core::ffi::c_void,
}
impl Copy for FLT_PARAMETERS_31 {}
impl Clone for FLT_PARAMETERS_31 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C, packed(4))]
pub struct FLT_PARAMETERS_32 {
    pub Length: u32,
    pub Key: u32,
    pub ByteOffset: i64,
    pub WriteBuffer: *mut core::ffi::c_void,
    pub MdlAddress: *mut MDL,
}
impl Copy for FLT_PARAMETERS_32 {}
impl Clone for FLT_PARAMETERS_32 {
    fn clone(&self) -> Self {
        *self
    }
}
pub type FLT_POSTOP_CALLBACK_STATUS = i32;
pub const FLT_POSTOP_FINISHED_PROCESSING: FLT_POSTOP_CALLBACK_STATUS = 0i32;
pub type FLT_PREOP_CALLBACK_STATUS = i32;
pub const FLT_PREOP_SUCCESS_NO_CALLBACK: FLT_PREOP_CALLBACK_STATUS = 1i32;
#[repr(C)]
pub struct FLT_REGISTRATION {
    pub Size: u16,
    pub Version: u16,
    pub Flags: u32,
    pub ContextRegistration: *const FLT_CONTEXT_REGISTRATION,
    pub OperationRegistration: *const FLT_OPERATION_REGISTRATION,
    pub FilterUnloadCallback: PFLT_FILTER_UNLOAD_CALLBACK,
    pub InstanceSetupCallback: PFLT_INSTANCE_SETUP_CALLBACK,
    pub InstanceQueryTeardownCallback: PFLT_INSTANCE_QUERY_TEARDOWN_CALLBACK,
    pub InstanceTeardownStartCallback: PFLT_INSTANCE_TEARDOWN_CALLBACK,
    pub InstanceTeardownCompleteCallback: PFLT_INSTANCE_TEARDOWN_CALLBACK,
    pub GenerateFileNameCallback: PFLT_GENERATE_FILE_NAME,
    pub NormalizeNameComponentCallback: PFLT_NORMALIZE_NAME_COMPONENT,
    pub NormalizeContextCleanupCallback: PFLT_NORMALIZE_CONTEXT_CLEANUP,
    pub TransactionNotificationCallback: PFLT_TRANSACTION_NOTIFICATION_CALLBACK,
    pub NormalizeNameComponentExCallback: PFLT_NORMALIZE_NAME_COMPONENT_EX,
    pub SectionNotificationCallback: PFLT_SECTION_CONFLICT_NOTIFICATION_CALLBACK,
}
impl Copy for FLT_REGISTRATION {}
impl Clone for FLT_REGISTRATION {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_RELATED_OBJECTS {
    pub Size: u16,
    pub TransactionContext: u16,
    pub Filter: PFLT_FILTER,
    pub Volume: PFLT_VOLUME,
    pub Instance: PFLT_INSTANCE,
    pub FileObject: *const FILE_OBJECT,
    pub Transaction: *const KTRANSACTION,
}
impl Copy for FLT_RELATED_OBJECTS {}
impl Clone for FLT_RELATED_OBJECTS {
    fn clone(&self) -> Self {
        *self
    }
}
pub const FLT_STREAMHANDLE_CONTEXT: u32 = 16u32;
#[repr(C)]
pub struct FLT_TAG_DATA_BUFFER {
    pub FileTag: u32,
    pub TagDataLength: u16,
    pub UnparsedNameLength: u16,
    pub Anonymous: FLT_TAG_DATA_BUFFER_0,
}
impl Copy for FLT_TAG_DATA_BUFFER {}
impl Clone for FLT_TAG_DATA_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub union FLT_TAG_DATA_BUFFER_0 {
    pub SymbolicLinkReparseBuffer: FLT_TAG_DATA_BUFFER_0_3,
    pub MountPointReparseBuffer: FLT_TAG_DATA_BUFFER_0_2,
    pub GenericReparseBuffer: FLT_TAG_DATA_BUFFER_0_1,
    pub GenericGUIDReparseBuffer: FLT_TAG_DATA_BUFFER_0_0,
}
impl Copy for FLT_TAG_DATA_BUFFER_0 {}
impl Clone for FLT_TAG_DATA_BUFFER_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_TAG_DATA_BUFFER_0_0 {
    pub TagGuid: GUID,
    pub DataBuffer: [u8; 1],
}
impl Copy for FLT_TAG_DATA_BUFFER_0_0 {}
impl Clone for FLT_TAG_DATA_BUFFER_0_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_TAG_DATA_BUFFER_0_1 {
    pub DataBuffer: [u8; 1],
}
impl Copy for FLT_TAG_DATA_BUFFER_0_1 {}
impl Clone for FLT_TAG_DATA_BUFFER_0_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_TAG_DATA_BUFFER_0_2 {
    pub SubstituteNameOffset: u16,
    pub SubstituteNameLength: u16,
    pub PrintNameOffset: u16,
    pub PrintNameLength: u16,
    pub PathBuffer: [u16; 1],
}
impl Copy for FLT_TAG_DATA_BUFFER_0_2 {}
impl Clone for FLT_TAG_DATA_BUFFER_0_2 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct FLT_TAG_DATA_BUFFER_0_3 {
    pub SubstituteNameOffset: u16,
    pub SubstituteNameLength: u16,
    pub PrintNameOffset: u16,
    pub PrintNameLength: u16,
    pub Flags: u32,
    pub PathBuffer: [u16; 1],
}
impl Copy for FLT_TAG_DATA_BUFFER_0_3 {}
impl Clone for FLT_TAG_DATA_BUFFER_0_3 {
    fn clone(&self) -> Self {
        *self
    }
}
pub const FLT_TRANSACTION_CONTEXT: u32 = 32u32;
#[repr(C)]
pub struct FS_FILTER_SECTION_SYNC_OUTPUT {
    pub StructureSize: u32,
    pub SizeReturned: u32,
    pub Flags: u32,
    pub DesiredReadAlignment: u32,
}
impl Copy for FS_FILTER_SECTION_SYNC_OUTPUT {}
impl Clone for FS_FILTER_SECTION_SYNC_OUTPUT {
    fn clone(&self) -> Self {
        *self
    }
}
pub type FS_FILTER_SECTION_SYNC_TYPE = i32;
pub type FS_INFORMATION_CLASS = i32;
#[repr(C)]
pub struct GUID {
    pub data1: u32,
    pub data2: u16,
    pub data3: u16,
    pub data4: [u8; 8],
}
impl Copy for GUID {}
impl Clone for GUID {
    fn clone(&self) -> Self {
        *self
    }
}
impl GUID {
    pub const fn from_u128(uuid: u128) -> Self {
        Self {
            data1: (uuid >> 96) as u32,
            data2: (uuid >> 80 & 0xffff) as u16,
            data3: (uuid >> 64 & 0xffff) as u16,
            data4: (uuid as u64).to_be_bytes(),
        }
    }
}
pub type HANDLE = isize;
#[repr(C)]
pub struct INITIAL_PRIVILEGE_SET {
    pub PrivilegeCount: u32,
    pub Control: u32,
    pub Privilege: [LUID_AND_ATTRIBUTES; 3],
}
impl Copy for INITIAL_PRIVILEGE_SET {}
impl Clone for INITIAL_PRIVILEGE_SET {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct INTERFACE {
    pub Size: u16,
    pub Version: u16,
    pub Context: *mut core::ffi::c_void,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
}
impl Copy for INTERFACE {}
impl Clone for INTERFACE {
    fn clone(&self) -> Self {
        *self
    }
}
pub type INTERFACE_TYPE = i32;
pub type IO_ALLOCATION_ACTION = i32;
#[repr(C)]
pub struct IO_COMPLETION_CONTEXT {
    pub Port: *mut core::ffi::c_void,
    pub Key: *mut core::ffi::c_void,
    pub UsageCount: isize,
}
impl Copy for IO_COMPLETION_CONTEXT {}
impl Clone for IO_COMPLETION_CONTEXT {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_RESOURCE_DESCRIPTOR {
    pub Option: u8,
    pub Type: u8,
    pub ShareDisposition: u8,
    pub Spare1: u8,
    pub Flags: u16,
    pub Spare2: u16,
    pub u: IO_RESOURCE_DESCRIPTOR_0,
}
impl Copy for IO_RESOURCE_DESCRIPTOR {}
impl Clone for IO_RESOURCE_DESCRIPTOR {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub union IO_RESOURCE_DESCRIPTOR_0 {
    pub Port: IO_RESOURCE_DESCRIPTOR_0_12,
    pub Memory: IO_RESOURCE_DESCRIPTOR_0_11,
    pub Interrupt: IO_RESOURCE_DESCRIPTOR_0_7,
    pub Dma: IO_RESOURCE_DESCRIPTOR_0_5,
    pub DmaV3: IO_RESOURCE_DESCRIPTOR_0_4,
    pub Generic: IO_RESOURCE_DESCRIPTOR_0_6,
    pub DevicePrivate: IO_RESOURCE_DESCRIPTOR_0_3,
    pub BusNumber: IO_RESOURCE_DESCRIPTOR_0_0,
    pub ConfigData: IO_RESOURCE_DESCRIPTOR_0_1,
    pub Memory40: IO_RESOURCE_DESCRIPTOR_0_8,
    pub Memory48: IO_RESOURCE_DESCRIPTOR_0_9,
    pub Memory64: IO_RESOURCE_DESCRIPTOR_0_10,
    pub Connection: IO_RESOURCE_DESCRIPTOR_0_2,
}
impl Copy for IO_RESOURCE_DESCRIPTOR_0 {}
impl Clone for IO_RESOURCE_DESCRIPTOR_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_RESOURCE_DESCRIPTOR_0_0 {
    pub Length: u32,
    pub MinBusNumber: u32,
    pub MaxBusNumber: u32,
    pub Reserved: u32,
}
impl Copy for IO_RESOURCE_DESCRIPTOR_0_0 {}
impl Clone for IO_RESOURCE_DESCRIPTOR_0_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_RESOURCE_DESCRIPTOR_0_1 {
    pub Priority: u32,
    pub Reserved1: u32,
    pub Reserved2: u32,
}
impl Copy for IO_RESOURCE_DESCRIPTOR_0_1 {}
impl Clone for IO_RESOURCE_DESCRIPTOR_0_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_RESOURCE_DESCRIPTOR_0_2 {
    pub Class: u8,
    pub Type: u8,
    pub Reserved1: u8,
    pub Reserved2: u8,
    pub IdLowPart: u32,
    pub IdHighPart: u32,
}
impl Copy for IO_RESOURCE_DESCRIPTOR_0_2 {}
impl Clone for IO_RESOURCE_DESCRIPTOR_0_2 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_RESOURCE_DESCRIPTOR_0_3 {
    pub Data: [u32; 3],
}
impl Copy for IO_RESOURCE_DESCRIPTOR_0_3 {}
impl Clone for IO_RESOURCE_DESCRIPTOR_0_3 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_RESOURCE_DESCRIPTOR_0_4 {
    pub RequestLine: u32,
    pub Reserved: u32,
    pub Channel: u32,
    pub TransferWidth: u32,
}
impl Copy for IO_RESOURCE_DESCRIPTOR_0_4 {}
impl Clone for IO_RESOURCE_DESCRIPTOR_0_4 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_RESOURCE_DESCRIPTOR_0_5 {
    pub MinimumChannel: u32,
    pub MaximumChannel: u32,
}
impl Copy for IO_RESOURCE_DESCRIPTOR_0_5 {}
impl Clone for IO_RESOURCE_DESCRIPTOR_0_5 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_RESOURCE_DESCRIPTOR_0_6 {
    pub Length: u32,
    pub Alignment: u32,
    pub MinimumAddress: i64,
    pub MaximumAddress: i64,
}
impl Copy for IO_RESOURCE_DESCRIPTOR_0_6 {}
impl Clone for IO_RESOURCE_DESCRIPTOR_0_6 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_RESOURCE_DESCRIPTOR_0_7 {
    pub MinimumVector: u32,
    pub MaximumVector: u32,
    pub AffinityPolicy: IRQ_DEVICE_POLICY,
    pub PriorityPolicy: IRQ_PRIORITY,
    pub TargetedProcessors: usize,
}
impl Copy for IO_RESOURCE_DESCRIPTOR_0_7 {}
impl Clone for IO_RESOURCE_DESCRIPTOR_0_7 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_RESOURCE_DESCRIPTOR_0_8 {
    pub Length40: u32,
    pub Alignment40: u32,
    pub MinimumAddress: i64,
    pub MaximumAddress: i64,
}
impl Copy for IO_RESOURCE_DESCRIPTOR_0_8 {}
impl Clone for IO_RESOURCE_DESCRIPTOR_0_8 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_RESOURCE_DESCRIPTOR_0_9 {
    pub Length48: u32,
    pub Alignment48: u32,
    pub MinimumAddress: i64,
    pub MaximumAddress: i64,
}
impl Copy for IO_RESOURCE_DESCRIPTOR_0_9 {}
impl Clone for IO_RESOURCE_DESCRIPTOR_0_9 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_RESOURCE_DESCRIPTOR_0_10 {
    pub Length64: u32,
    pub Alignment64: u32,
    pub MinimumAddress: i64,
    pub MaximumAddress: i64,
}
impl Copy for IO_RESOURCE_DESCRIPTOR_0_10 {}
impl Clone for IO_RESOURCE_DESCRIPTOR_0_10 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_RESOURCE_DESCRIPTOR_0_11 {
    pub Length: u32,
    pub Alignment: u32,
    pub MinimumAddress: i64,
    pub MaximumAddress: i64,
}
impl Copy for IO_RESOURCE_DESCRIPTOR_0_11 {}
impl Clone for IO_RESOURCE_DESCRIPTOR_0_11 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_RESOURCE_DESCRIPTOR_0_12 {
    pub Length: u32,
    pub Alignment: u32,
    pub MinimumAddress: i64,
    pub MaximumAddress: i64,
}
impl Copy for IO_RESOURCE_DESCRIPTOR_0_12 {}
impl Clone for IO_RESOURCE_DESCRIPTOR_0_12 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_RESOURCE_LIST {
    pub Version: u16,
    pub Revision: u16,
    pub Count: u32,
    pub Descriptors: [IO_RESOURCE_DESCRIPTOR; 1],
}
impl Copy for IO_RESOURCE_LIST {}
impl Clone for IO_RESOURCE_LIST {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_RESOURCE_REQUIREMENTS_LIST {
    pub ListSize: u32,
    pub InterfaceType: INTERFACE_TYPE,
    pub BusNumber: u32,
    pub SlotNumber: u32,
    pub Reserved: [u32; 3],
    pub AlternativeLists: u32,
    pub List: [IO_RESOURCE_LIST; 1],
}
impl Copy for IO_RESOURCE_REQUIREMENTS_LIST {}
impl Clone for IO_RESOURCE_REQUIREMENTS_LIST {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_SECURITY_CONTEXT {
    pub SecurityQos: *mut SECURITY_QUALITY_OF_SERVICE,
    pub AccessState: *mut ACCESS_STATE,
    pub DesiredAccess: u32,
    pub FullCreateOptions: u32,
}
impl Copy for IO_SECURITY_CONTEXT {}
impl Clone for IO_SECURITY_CONTEXT {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_STACK_LOCATION {
    pub MajorFunction: u8,
    pub MinorFunction: u8,
    pub Flags: u8,
    pub Control: u8,
    pub Parameters: IO_STACK_LOCATION_0,
    pub DeviceObject: *mut DEVICE_OBJECT,
    pub FileObject: *mut FILE_OBJECT,
    pub CompletionRoutine: PIO_COMPLETION_ROUTINE,
    pub Context: *mut core::ffi::c_void,
}
impl Copy for IO_STACK_LOCATION {}
impl Clone for IO_STACK_LOCATION {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub union IO_STACK_LOCATION_0 {
    pub Create: IO_STACK_LOCATION_0_2,
    pub CreatePipe: IO_STACK_LOCATION_0_1,
    pub CreateMailslot: IO_STACK_LOCATION_0_0,
    pub Read: IO_STACK_LOCATION_0_25,
    pub Write: IO_STACK_LOCATION_0_38,
    pub QueryDirectory: IO_STACK_LOCATION_0_16,
    pub NotifyDirectory: IO_STACK_LOCATION_0_10,
    pub NotifyDirectoryEx: IO_STACK_LOCATION_0_9,
    pub QueryFile: IO_STACK_LOCATION_0_18,
    pub SetFile: IO_STACK_LOCATION_0_28,
    pub QueryEa: IO_STACK_LOCATION_0_17,
    pub SetEa: IO_STACK_LOCATION_0_27,
    pub QueryVolume: IO_STACK_LOCATION_0_23,
    pub SetVolume: IO_STACK_LOCATION_0_32,
    pub FileSystemControl: IO_STACK_LOCATION_0_5,
    pub LockControl: IO_STACK_LOCATION_0_7,
    pub DeviceIoControl: IO_STACK_LOCATION_0_4,
    pub QuerySecurity: IO_STACK_LOCATION_0_22,
    pub SetSecurity: IO_STACK_LOCATION_0_31,
    pub MountVolume: IO_STACK_LOCATION_0_8,
    pub VerifyVolume: IO_STACK_LOCATION_0_35,
    pub Scsi: IO_STACK_LOCATION_0_26,
    pub QueryQuota: IO_STACK_LOCATION_0_21,
    pub SetQuota: IO_STACK_LOCATION_0_30,
    pub QueryDeviceRelations: IO_STACK_LOCATION_0_14,
    pub QueryInterface: IO_STACK_LOCATION_0_20,
    pub DeviceCapabilities: IO_STACK_LOCATION_0_3,
    pub FilterResourceRequirements: IO_STACK_LOCATION_0_6,
    pub ReadWriteConfig: IO_STACK_LOCATION_0_24,
    pub SetLock: IO_STACK_LOCATION_0_29,
    pub QueryId: IO_STACK_LOCATION_0_19,
    pub QueryDeviceText: IO_STACK_LOCATION_0_15,
    pub UsageNotification: IO_STACK_LOCATION_0_34,
    pub WaitWake: IO_STACK_LOCATION_0_37,
    pub PowerSequence: IO_STACK_LOCATION_0_12,
    pub Power: IO_STACK_LOCATION_0_13,
    pub StartDevice: IO_STACK_LOCATION_0_33,
    pub WMI: IO_STACK_LOCATION_0_36,
    pub Others: IO_STACK_LOCATION_0_11,
}
impl Copy for IO_STACK_LOCATION_0 {}
impl Clone for IO_STACK_LOCATION_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_STACK_LOCATION_0_0 {
    pub SecurityContext: *mut IO_SECURITY_CONTEXT,
    pub Options: u32,
    pub Reserved: u16,
    pub ShareAccess: u16,
    pub Parameters: *mut MAILSLOT_CREATE_PARAMETERS,
}
impl Copy for IO_STACK_LOCATION_0_0 {}
impl Clone for IO_STACK_LOCATION_0_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_STACK_LOCATION_0_1 {
    pub SecurityContext: *mut IO_SECURITY_CONTEXT,
    pub Options: u32,
    pub Reserved: u16,
    pub ShareAccess: u16,
    pub Parameters: *mut NAMED_PIPE_CREATE_PARAMETERS,
}
impl Copy for IO_STACK_LOCATION_0_1 {}
impl Clone for IO_STACK_LOCATION_0_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_STACK_LOCATION_0_2 {
    pub SecurityContext: *mut IO_SECURITY_CONTEXT,
    pub Options: u32,
    pub FileAttributes: u16,
    pub ShareAccess: u16,
    pub EaLength: u32,
}
impl Copy for IO_STACK_LOCATION_0_2 {}
impl Clone for IO_STACK_LOCATION_0_2 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_STACK_LOCATION_0_3 {
    pub Capabilities: *mut DEVICE_CAPABILITIES,
}
impl Copy for IO_STACK_LOCATION_0_3 {}
impl Clone for IO_STACK_LOCATION_0_3 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_STACK_LOCATION_0_4 {
    pub OutputBufferLength: u32,
    pub InputBufferLength: u32,
    pub IoControlCode: u32,
    pub Type3InputBuffer: *mut core::ffi::c_void,
}
impl Copy for IO_STACK_LOCATION_0_4 {}
impl Clone for IO_STACK_LOCATION_0_4 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_STACK_LOCATION_0_5 {
    pub OutputBufferLength: u32,
    pub InputBufferLength: u32,
    pub FsControlCode: u32,
    pub Type3InputBuffer: *mut core::ffi::c_void,
}
impl Copy for IO_STACK_LOCATION_0_5 {}
impl Clone for IO_STACK_LOCATION_0_5 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_STACK_LOCATION_0_6 {
    pub IoResourceRequirementList: *mut IO_RESOURCE_REQUIREMENTS_LIST,
}
impl Copy for IO_STACK_LOCATION_0_6 {}
impl Clone for IO_STACK_LOCATION_0_6 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C, packed(4))]
pub struct IO_STACK_LOCATION_0_7 {
    pub Length: *mut i64,
    pub Key: u32,
    pub ByteOffset: i64,
}
impl Copy for IO_STACK_LOCATION_0_7 {}
impl Clone for IO_STACK_LOCATION_0_7 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_STACK_LOCATION_0_8 {
    pub Vpb: *mut VPB,
    pub DeviceObject: *mut DEVICE_OBJECT,
}
impl Copy for IO_STACK_LOCATION_0_8 {}
impl Clone for IO_STACK_LOCATION_0_8 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_STACK_LOCATION_0_9 {
    pub Length: u32,
    pub CompletionFilter: u32,
    pub DirectoryNotifyInformationClass: DIRECTORY_NOTIFY_INFORMATION_CLASS,
}
impl Copy for IO_STACK_LOCATION_0_9 {}
impl Clone for IO_STACK_LOCATION_0_9 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_STACK_LOCATION_0_10 {
    pub Length: u32,
    pub CompletionFilter: u32,
}
impl Copy for IO_STACK_LOCATION_0_10 {}
impl Clone for IO_STACK_LOCATION_0_10 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_STACK_LOCATION_0_11 {
    pub Argument1: *mut core::ffi::c_void,
    pub Argument2: *mut core::ffi::c_void,
    pub Argument3: *mut core::ffi::c_void,
    pub Argument4: *mut core::ffi::c_void,
}
impl Copy for IO_STACK_LOCATION_0_11 {}
impl Clone for IO_STACK_LOCATION_0_11 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_STACK_LOCATION_0_12 {
    pub PowerSequence: *mut POWER_SEQUENCE,
}
impl Copy for IO_STACK_LOCATION_0_12 {}
impl Clone for IO_STACK_LOCATION_0_12 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_STACK_LOCATION_0_13 {
    pub Anonymous: IO_STACK_LOCATION_0_13_0,
    pub Type: POWER_STATE_TYPE,
    pub State: POWER_STATE,
    pub ShutdownType: POWER_ACTION,
}
impl Copy for IO_STACK_LOCATION_0_13 {}
impl Clone for IO_STACK_LOCATION_0_13 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub union IO_STACK_LOCATION_0_13_0 {
    pub SystemContext: u32,
    pub SystemPowerStateContext: SYSTEM_POWER_STATE_CONTEXT,
}
impl Copy for IO_STACK_LOCATION_0_13_0 {}
impl Clone for IO_STACK_LOCATION_0_13_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_STACK_LOCATION_0_14 {
    pub Type: DEVICE_RELATION_TYPE,
}
impl Copy for IO_STACK_LOCATION_0_14 {}
impl Clone for IO_STACK_LOCATION_0_14 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_STACK_LOCATION_0_15 {
    pub DeviceTextType: DEVICE_TEXT_TYPE,
    pub LocaleId: u32,
}
impl Copy for IO_STACK_LOCATION_0_15 {}
impl Clone for IO_STACK_LOCATION_0_15 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_STACK_LOCATION_0_16 {
    pub Length: u32,
    pub FileName: *mut UNICODE_STRING,
    pub FileInformationClass: FILE_INFORMATION_CLASS,
    pub FileIndex: u32,
}
impl Copy for IO_STACK_LOCATION_0_16 {}
impl Clone for IO_STACK_LOCATION_0_16 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_STACK_LOCATION_0_17 {
    pub Length: u32,
    pub EaList: *mut core::ffi::c_void,
    pub EaListLength: u32,
    pub EaIndex: u32,
}
impl Copy for IO_STACK_LOCATION_0_17 {}
impl Clone for IO_STACK_LOCATION_0_17 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_STACK_LOCATION_0_18 {
    pub Length: u32,
    pub FileInformationClass: FILE_INFORMATION_CLASS,
}
impl Copy for IO_STACK_LOCATION_0_18 {}
impl Clone for IO_STACK_LOCATION_0_18 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_STACK_LOCATION_0_19 {
    pub IdType: BUS_QUERY_ID_TYPE,
}
impl Copy for IO_STACK_LOCATION_0_19 {}
impl Clone for IO_STACK_LOCATION_0_19 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_STACK_LOCATION_0_20 {
    pub InterfaceType: *const GUID,
    pub Size: u16,
    pub Version: u16,
    pub Interface: *mut INTERFACE,
    pub InterfaceSpecificData: *mut core::ffi::c_void,
}
impl Copy for IO_STACK_LOCATION_0_20 {}
impl Clone for IO_STACK_LOCATION_0_20 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_STACK_LOCATION_0_21 {
    pub Length: u32,
    pub StartSid: PSID,
    pub SidList: *mut FILE_GET_QUOTA_INFORMATION,
    pub SidListLength: u32,
}
impl Copy for IO_STACK_LOCATION_0_21 {}
impl Clone for IO_STACK_LOCATION_0_21 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_STACK_LOCATION_0_22 {
    pub SecurityInformation: u32,
    pub Length: u32,
}
impl Copy for IO_STACK_LOCATION_0_22 {}
impl Clone for IO_STACK_LOCATION_0_22 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_STACK_LOCATION_0_23 {
    pub Length: u32,
    pub FsInformationClass: FS_INFORMATION_CLASS,
}
impl Copy for IO_STACK_LOCATION_0_23 {}
impl Clone for IO_STACK_LOCATION_0_23 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_STACK_LOCATION_0_24 {
    pub WhichSpace: u32,
    pub Buffer: *mut core::ffi::c_void,
    pub Offset: u32,
    pub Length: u32,
}
impl Copy for IO_STACK_LOCATION_0_24 {}
impl Clone for IO_STACK_LOCATION_0_24 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C, packed(4))]
pub struct IO_STACK_LOCATION_0_25 {
    pub Length: u32,
    pub Key: u32,
    pub ByteOffset: i64,
}
impl Copy for IO_STACK_LOCATION_0_25 {}
impl Clone for IO_STACK_LOCATION_0_25 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_STACK_LOCATION_0_26 {
    pub Srb: *mut _SCSI_REQUEST_BLOCK,
}
impl Copy for IO_STACK_LOCATION_0_26 {}
impl Clone for IO_STACK_LOCATION_0_26 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_STACK_LOCATION_0_27 {
    pub Length: u32,
}
impl Copy for IO_STACK_LOCATION_0_27 {}
impl Clone for IO_STACK_LOCATION_0_27 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_STACK_LOCATION_0_28 {
    pub Length: u32,
    pub FileInformationClass: FILE_INFORMATION_CLASS,
    pub FileObject: *mut FILE_OBJECT,
    pub Anonymous: IO_STACK_LOCATION_0_28_0,
}
impl Copy for IO_STACK_LOCATION_0_28 {}
impl Clone for IO_STACK_LOCATION_0_28 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub union IO_STACK_LOCATION_0_28_0 {
    pub Anonymous: IO_STACK_LOCATION_0_28_0_0,
    pub ClusterCount: u32,
    pub DeleteHandle: HANDLE,
}
impl Copy for IO_STACK_LOCATION_0_28_0 {}
impl Clone for IO_STACK_LOCATION_0_28_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_STACK_LOCATION_0_28_0_0 {
    pub ReplaceIfExists: BOOLEAN,
    pub AdvanceOnly: BOOLEAN,
}
impl Copy for IO_STACK_LOCATION_0_28_0_0 {}
impl Clone for IO_STACK_LOCATION_0_28_0_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_STACK_LOCATION_0_29 {
    pub Lock: BOOLEAN,
}
impl Copy for IO_STACK_LOCATION_0_29 {}
impl Clone for IO_STACK_LOCATION_0_29 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_STACK_LOCATION_0_30 {
    pub Length: u32,
}
impl Copy for IO_STACK_LOCATION_0_30 {}
impl Clone for IO_STACK_LOCATION_0_30 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_STACK_LOCATION_0_31 {
    pub SecurityInformation: u32,
    pub SecurityDescriptor: PSECURITY_DESCRIPTOR,
}
impl Copy for IO_STACK_LOCATION_0_31 {}
impl Clone for IO_STACK_LOCATION_0_31 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_STACK_LOCATION_0_32 {
    pub Length: u32,
    pub FsInformationClass: FS_INFORMATION_CLASS,
}
impl Copy for IO_STACK_LOCATION_0_32 {}
impl Clone for IO_STACK_LOCATION_0_32 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_STACK_LOCATION_0_33 {
    pub AllocatedResources: *mut CM_RESOURCE_LIST,
    pub AllocatedResourcesTranslated: *mut CM_RESOURCE_LIST,
}
impl Copy for IO_STACK_LOCATION_0_33 {}
impl Clone for IO_STACK_LOCATION_0_33 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_STACK_LOCATION_0_34 {
    pub InPath: BOOLEAN,
    pub Reserved: [BOOLEAN; 3],
    pub Type: DEVICE_USAGE_NOTIFICATION_TYPE,
}
impl Copy for IO_STACK_LOCATION_0_34 {}
impl Clone for IO_STACK_LOCATION_0_34 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_STACK_LOCATION_0_35 {
    pub Vpb: *mut VPB,
    pub DeviceObject: *mut DEVICE_OBJECT,
}
impl Copy for IO_STACK_LOCATION_0_35 {}
impl Clone for IO_STACK_LOCATION_0_35 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_STACK_LOCATION_0_36 {
    pub ProviderId: usize,
    pub DataPath: *mut core::ffi::c_void,
    pub BufferSize: u32,
    pub Buffer: *mut core::ffi::c_void,
}
impl Copy for IO_STACK_LOCATION_0_36 {}
impl Clone for IO_STACK_LOCATION_0_36 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_STACK_LOCATION_0_37 {
    pub PowerState: SYSTEM_POWER_STATE,
}
impl Copy for IO_STACK_LOCATION_0_37 {}
impl Clone for IO_STACK_LOCATION_0_37 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C, packed(4))]
pub struct IO_STACK_LOCATION_0_38 {
    pub Length: u32,
    pub Key: u32,
    pub ByteOffset: i64,
}
impl Copy for IO_STACK_LOCATION_0_38 {}
impl Clone for IO_STACK_LOCATION_0_38 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IO_STATUS_BLOCK {
    pub Anonymous: IO_STATUS_BLOCK_0,
    pub Information: usize,
}
impl Copy for IO_STATUS_BLOCK {}
impl Clone for IO_STATUS_BLOCK {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub union IO_STATUS_BLOCK_0 {
    pub Status: NTSTATUS,
    pub Pointer: *mut core::ffi::c_void,
}
impl Copy for IO_STATUS_BLOCK_0 {}
impl Clone for IO_STATUS_BLOCK_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IRP {
    pub Type: i16,
    pub Size: u16,
    pub MdlAddress: *mut MDL,
    pub Flags: u32,
    pub AssociatedIrp: IRP_1,
    pub ThreadListEntry: LIST_ENTRY,
    pub IoStatus: IO_STATUS_BLOCK,
    pub RequestorMode: i8,
    pub PendingReturned: BOOLEAN,
    pub StackCount: i8,
    pub CurrentLocation: i8,
    pub Cancel: BOOLEAN,
    pub CancelIrql: u8,
    pub ApcEnvironment: i8,
    pub AllocationFlags: u8,
    pub Anonymous: IRP_0,
    pub UserEvent: *mut KEVENT,
    pub Overlay: IRP_2,
    pub CancelRoutine: *mut DRIVER_CANCEL,
    pub UserBuffer: *mut core::ffi::c_void,
    pub Tail: IRP_3,
}
impl Copy for IRP {}
impl Clone for IRP {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub union IRP_0 {
    pub UserIosb: *mut IO_STATUS_BLOCK,
    pub IoRingContext: *mut core::ffi::c_void,
}
impl Copy for IRP_0 {}
impl Clone for IRP_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub union IRP_1 {
    pub MasterIrp: *mut IRP,
    pub IrpCount: i32,
    pub SystemBuffer: *mut core::ffi::c_void,
}
impl Copy for IRP_1 {}
impl Clone for IRP_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub union IRP_2 {
    pub AsynchronousParameters: IRP_2_0,
    pub AllocationSize: i64,
}
impl Copy for IRP_2 {}
impl Clone for IRP_2 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IRP_2_0 {
    pub Anonymous1: IRP_2_0_0,
    pub Anonymous2: IRP_2_0_1,
}
impl Copy for IRP_2_0 {}
impl Clone for IRP_2_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub union IRP_2_0_0 {
    pub UserApcRoutine: PIO_APC_ROUTINE,
    pub IssuingProcess: *mut core::ffi::c_void,
}
impl Copy for IRP_2_0_0 {}
impl Clone for IRP_2_0_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub union IRP_2_0_1 {
    pub UserApcContext: *mut core::ffi::c_void,
    pub IoRing: *mut _IORING_OBJECT,
}
impl Copy for IRP_2_0_1 {}
impl Clone for IRP_2_0_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub union IRP_3 {
    pub Overlay: IRP_3_0,
    pub Apc: KAPC,
    pub CompletionKey: *mut core::ffi::c_void,
}
impl Copy for IRP_3 {}
impl Clone for IRP_3 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IRP_3_0 {
    pub Anonymous1: IRP_3_0_0,
    pub Thread: PETHREAD,
    pub AuxiliaryBuffer: PSTR,
    pub Anonymous2: IRP_3_0_1,
    pub OriginalFileObject: *mut FILE_OBJECT,
}
impl Copy for IRP_3_0 {}
impl Clone for IRP_3_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub union IRP_3_0_0 {
    pub DeviceQueueEntry: KDEVICE_QUEUE_ENTRY,
    pub Anonymous: IRP_3_0_0_0,
}
impl Copy for IRP_3_0_0 {}
impl Clone for IRP_3_0_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IRP_3_0_0_0 {
    pub DriverContext: [*mut core::ffi::c_void; 4],
}
impl Copy for IRP_3_0_0_0 {}
impl Clone for IRP_3_0_0_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct IRP_3_0_1 {
    pub ListEntry: LIST_ENTRY,
    pub Anonymous: IRP_3_0_1_0,
}
impl Copy for IRP_3_0_1 {}
impl Clone for IRP_3_0_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub union IRP_3_0_1_0 {
    pub CurrentStackLocation: *mut IO_STACK_LOCATION,
    pub PacketType: u32,
}
impl Copy for IRP_3_0_1_0 {}
impl Clone for IRP_3_0_1_0 {
    fn clone(&self) -> Self {
        *self
    }
}
pub const IRP_MJ_ACQUIRE_FOR_CC_FLUSH: u16 = 65531u16;
pub const IRP_MJ_ACQUIRE_FOR_SECTION_SYNCHRONIZATION: u16 = 65535u16;
pub const IRP_MJ_CLEANUP: u32 = 18u32;
pub const IRP_MJ_CLOSE: u32 = 2u32;
pub const IRP_MJ_CREATE: u32 = 0u32;
pub const IRP_MJ_CREATE_MAILSLOT: u32 = 19u32;
pub const IRP_MJ_CREATE_NAMED_PIPE: u32 = 1u32;
pub const IRP_MJ_DEVICE_CONTROL: u32 = 14u32;
pub const IRP_MJ_DIRECTORY_CONTROL: u32 = 12u32;
pub const IRP_MJ_FAST_IO_CHECK_IF_POSSIBLE: u16 = 65523u16;
pub const IRP_MJ_FILE_SYSTEM_CONTROL: u32 = 13u32;
pub const IRP_MJ_FLUSH_BUFFERS: u32 = 9u32;
pub const IRP_MJ_INTERNAL_DEVICE_CONTROL: u32 = 15u32;
pub const IRP_MJ_LOCK_CONTROL: u32 = 17u32;
pub const IRP_MJ_MDL_READ: u16 = 65521u16;
pub const IRP_MJ_MDL_READ_COMPLETE: u16 = 65520u16;
pub const IRP_MJ_MDL_WRITE_COMPLETE: u16 = 65518u16;
pub const IRP_MJ_NETWORK_QUERY_OPEN: u16 = 65522u16;
pub const IRP_MJ_OPERATION_END: u16 = 128u16;
pub const IRP_MJ_PNP: u32 = 27u32;
pub const IRP_MJ_PREPARE_MDL_WRITE: u16 = 65519u16;
pub const IRP_MJ_QUERY_EA: u32 = 7u32;
pub const IRP_MJ_QUERY_INFORMATION: u32 = 5u32;
pub const IRP_MJ_QUERY_QUOTA: u32 = 25u32;
pub const IRP_MJ_QUERY_SECURITY: u32 = 20u32;
pub const IRP_MJ_QUERY_VOLUME_INFORMATION: u32 = 10u32;
pub const IRP_MJ_READ: u32 = 3u32;
pub const IRP_MJ_RELEASE_FOR_MOD_WRITE: u16 = 65532u16;
pub const IRP_MJ_SET_EA: u32 = 8u32;
pub const IRP_MJ_SET_INFORMATION: u32 = 6u32;
pub const IRP_MJ_SET_QUOTA: u32 = 26u32;
pub const IRP_MJ_SET_SECURITY: u32 = 21u32;
pub const IRP_MJ_SET_VOLUME_INFORMATION: u32 = 11u32;
pub const IRP_MJ_SHUTDOWN: u32 = 16u32;
pub const IRP_MJ_VOLUME_DISMOUNT: u16 = 65516u16;
pub const IRP_MJ_VOLUME_MOUNT: u16 = 65517u16;
pub const IRP_MJ_WRITE: u32 = 4u32;
pub type IRQ_DEVICE_POLICY = i32;
pub type IRQ_PRIORITY = i32;
#[repr(C)]
pub struct KAPC {
    pub Type: u8,
    pub AllFlags: u8,
    pub Size: u8,
    pub SpareByte1: u8,
    pub SpareLong0: u32,
    pub Thread: *mut isize,
    pub ApcListEntry: LIST_ENTRY,
    pub Reserved: [*mut core::ffi::c_void; 3],
    pub NormalContext: *mut core::ffi::c_void,
    pub SystemArgument1: *mut core::ffi::c_void,
    pub SystemArgument2: *mut core::ffi::c_void,
    pub ApcStateIndex: i8,
    pub ApcMode: i8,
    pub Inserted: BOOLEAN,
}
impl Copy for KAPC {}
impl Clone for KAPC {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct KDEVICE_QUEUE {
    pub Type: i16,
    pub Size: i16,
    pub DeviceListHead: LIST_ENTRY,
    pub Lock: usize,
    pub Busy: BOOLEAN,
}
impl Copy for KDEVICE_QUEUE {}
impl Clone for KDEVICE_QUEUE {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct KDEVICE_QUEUE_ENTRY {
    pub DeviceListEntry: LIST_ENTRY,
    pub SortKey: u32,
    pub Inserted: BOOLEAN,
}
impl Copy for KDEVICE_QUEUE_ENTRY {}
impl Clone for KDEVICE_QUEUE_ENTRY {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct KDPC {
    pub Anonymous: KDPC_0,
    pub DpcListEntry: SINGLE_LIST_ENTRY,
    pub ProcessorHistory: usize,
    pub DeferredRoutine: PKDEFERRED_ROUTINE,
    pub DeferredContext: *mut core::ffi::c_void,
    pub SystemArgument1: *mut core::ffi::c_void,
    pub SystemArgument2: *mut core::ffi::c_void,
    pub DpcData: *mut core::ffi::c_void,
}
impl Copy for KDPC {}
impl Clone for KDPC {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub union KDPC_0 {
    pub TargetInfoAsUlong: u32,
    pub Anonymous: KDPC_0_0,
}
impl Copy for KDPC_0 {}
impl Clone for KDPC_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct KDPC_0_0 {
    pub Type: u8,
    pub Importance: u8,
    pub Number: u16,
}
impl Copy for KDPC_0_0 {}
impl Clone for KDPC_0_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct KEVENT {
    pub Header: DISPATCHER_HEADER,
}
impl Copy for KEVENT {}
impl Clone for KEVENT {
    fn clone(&self) -> Self {
        *self
    }
}
pub type KTRANSACTION = isize;
#[repr(C)]
pub struct LIST_ENTRY {
    pub Flink: *mut LIST_ENTRY,
    pub Blink: *mut LIST_ENTRY,
}
impl Copy for LIST_ENTRY {}
impl Clone for LIST_ENTRY {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct LUID {
    pub LowPart: u32,
    pub HighPart: i32,
}
impl Copy for LUID {}
impl Clone for LUID {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct LUID_AND_ATTRIBUTES {
    pub Luid: LUID,
    pub Attributes: TOKEN_PRIVILEGES_ATTRIBUTES,
}
impl Copy for LUID_AND_ATTRIBUTES {}
impl Clone for LUID_AND_ATTRIBUTES {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct MAILSLOT_CREATE_PARAMETERS {
    pub MailslotQuota: u32,
    pub MaximumMessageSize: u32,
    pub ReadTimeout: i64,
    pub TimeoutSpecified: BOOLEAN,
}
impl Copy for MAILSLOT_CREATE_PARAMETERS {}
impl Clone for MAILSLOT_CREATE_PARAMETERS {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct MDL {
    pub Next: *mut MDL,
    pub Size: i16,
    pub MdlFlags: i16,
    pub Process: *mut isize,
    pub MappedSystemVa: *mut core::ffi::c_void,
    pub StartVa: *mut core::ffi::c_void,
    pub ByteCount: u32,
    pub ByteOffset: u32,
}
impl Copy for MDL {}
impl Clone for MDL {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct NAMED_PIPE_CREATE_PARAMETERS {
    pub NamedPipeType: u32,
    pub ReadMode: u32,
    pub CompletionMode: u32,
    pub MaximumInstances: u32,
    pub InboundQuota: u32,
    pub OutboundQuota: u32,
    pub DefaultTimeout: i64,
    pub TimeoutSpecified: BOOLEAN,
}
impl Copy for NAMED_PIPE_CREATE_PARAMETERS {}
impl Clone for NAMED_PIPE_CREATE_PARAMETERS {
    fn clone(&self) -> Self {
        *self
    }
}
pub type NTSTATUS = i32;
#[repr(C)]
pub struct OBJECT_ATTRIBUTES {
    pub Length: u32,
    pub RootDirectory: HANDLE,
    pub ObjectName: *const UNICODE_STRING,
    pub Attributes: u32,
    pub SecurityDescriptor: *const core::ffi::c_void,
    pub SecurityQualityOfService: *const core::ffi::c_void,
}
impl Copy for OBJECT_ATTRIBUTES {}
impl Clone for OBJECT_ATTRIBUTES {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct OWNER_ENTRY {
    pub OwnerThread: usize,
    pub Anonymous: OWNER_ENTRY_0,
}
impl Copy for OWNER_ENTRY {}
impl Clone for OWNER_ENTRY {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub union OWNER_ENTRY_0 {
    pub Anonymous: OWNER_ENTRY_0_0,
    pub TableSize: u32,
}
impl Copy for OWNER_ENTRY_0 {}
impl Clone for OWNER_ENTRY_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct OWNER_ENTRY_0_0 {
    pub _bitfield: u32,
}
impl Copy for OWNER_ENTRY_0_0 {}
impl Clone for OWNER_ENTRY_0_0 {
    fn clone(&self) -> Self {
        *self
    }
}
pub type PEPROCESS = isize;
pub type PETHREAD = isize;
pub type PFLT_CONTEXT = *mut core::ffi::c_void;
pub type PFLT_CONTEXT_ALLOCATE_CALLBACK = Option<
    unsafe extern "system" fn(
        pooltype: POOL_TYPE,
        size: usize,
        contexttype: u16,
    ) -> *mut core::ffi::c_void,
>;
pub type PFLT_CONTEXT_CLEANUP_CALLBACK =
    Option<unsafe extern "system" fn(context: PFLT_CONTEXT, contexttype: u16)>;
pub type PFLT_CONTEXT_FREE_CALLBACK =
    Option<unsafe extern "system" fn(pool: *const core::ffi::c_void, contexttype: u16)>;
pub type PFLT_FILTER = isize;
pub type PFLT_FILTER_UNLOAD_CALLBACK = Option<unsafe extern "system" fn(flags: u32) -> NTSTATUS>;
pub type PFLT_GENERATE_FILE_NAME = Option<
    unsafe extern "system" fn(
        instance: PFLT_INSTANCE,
        fileobject: *const FILE_OBJECT,
        callbackdata: *const FLT_CALLBACK_DATA,
        nameoptions: u32,
        cachefilenameinformation: *mut BOOLEAN,
        filename: *mut FLT_NAME_CONTROL,
    ) -> NTSTATUS,
>;
pub type PFLT_INSTANCE = isize;
pub type PFLT_INSTANCE_QUERY_TEARDOWN_CALLBACK = Option<
    unsafe extern "system" fn(fltobjects: *const FLT_RELATED_OBJECTS, flags: u32) -> NTSTATUS,
>;
pub type PFLT_INSTANCE_SETUP_CALLBACK = Option<
    unsafe extern "system" fn(
        fltobjects: *const FLT_RELATED_OBJECTS,
        flags: u32,
        volumedevicetype: u32,
        volumefilesystemtype: FLT_FILESYSTEM_TYPE,
    ) -> NTSTATUS,
>;
pub type PFLT_INSTANCE_TEARDOWN_CALLBACK =
    Option<unsafe extern "system" fn(fltobjects: *const FLT_RELATED_OBJECTS, reason: u32)>;
pub type PFLT_NORMALIZE_CONTEXT_CLEANUP =
    Option<unsafe extern "system" fn(normalizationcontext: *const *const core::ffi::c_void)>;
pub type PFLT_NORMALIZE_NAME_COMPONENT = Option<
    unsafe extern "system" fn(
        instance: PFLT_INSTANCE,
        parentdirectory: *const UNICODE_STRING,
        volumenamelength: u16,
        component: *const UNICODE_STRING,
        expandcomponentname: *mut FILE_NAMES_INFORMATION,
        expandcomponentnamelength: u32,
        flags: u32,
        normalizationcontext: *mut *mut core::ffi::c_void,
    ) -> NTSTATUS,
>;
pub type PFLT_NORMALIZE_NAME_COMPONENT_EX = Option<
    unsafe extern "system" fn(
        instance: PFLT_INSTANCE,
        fileobject: *const FILE_OBJECT,
        parentdirectory: *const UNICODE_STRING,
        volumenamelength: u16,
        component: *const UNICODE_STRING,
        expandcomponentname: *mut FILE_NAMES_INFORMATION,
        expandcomponentnamelength: u32,
        flags: u32,
        normalizationcontext: *mut *mut core::ffi::c_void,
    ) -> NTSTATUS,
>;
pub type PFLT_PORT = isize;
pub type PFLT_POST_OPERATION_CALLBACK = Option<
    unsafe extern "system" fn(
        data: *mut FLT_CALLBACK_DATA,
        fltobjects: *const FLT_RELATED_OBJECTS,
        completioncontext: *const core::ffi::c_void,
        flags: u32,
    ) -> FLT_POSTOP_CALLBACK_STATUS,
>;
pub type PFLT_PRE_OPERATION_CALLBACK = Option<
    unsafe extern "system" fn(
        data: *mut FLT_CALLBACK_DATA,
        fltobjects: *const FLT_RELATED_OBJECTS,
        completioncontext: *mut *mut core::ffi::c_void,
    ) -> FLT_PREOP_CALLBACK_STATUS,
>;
pub type PFLT_SECTION_CONFLICT_NOTIFICATION_CALLBACK = Option<
    unsafe extern "system" fn(
        instance: PFLT_INSTANCE,
        sectioncontext: PFLT_CONTEXT,
        data: *const FLT_CALLBACK_DATA,
    ) -> NTSTATUS,
>;
pub type PFLT_TRANSACTION_NOTIFICATION_CALLBACK = Option<
    unsafe extern "system" fn(
        fltobjects: *const FLT_RELATED_OBJECTS,
        transactioncontext: PFLT_CONTEXT,
        notificationmask: u32,
    ) -> NTSTATUS,
>;
pub type PFLT_VOLUME = isize;
pub type PINTERFACE_DEREFERENCE =
    Option<unsafe extern "system" fn(context: *mut core::ffi::c_void)>;
pub type PINTERFACE_REFERENCE = Option<unsafe extern "system" fn(context: *mut core::ffi::c_void)>;
pub type PIO_APC_ROUTINE = Option<
    unsafe extern "system" fn(
        apccontext: *mut core::ffi::c_void,
        iostatusblock: *mut IO_STATUS_BLOCK,
        reserved: u32,
    ),
>;
pub type PIO_COMPLETION_ROUTINE = Option<unsafe extern "system" fn() -> NTSTATUS>;
pub type PIO_TIMER = isize;
pub type PKDEFERRED_ROUTINE = Option<unsafe extern "system" fn()>;
pub type POOL_TYPE = i32;
pub type POWER_ACTION = i32;
#[repr(C)]
pub struct POWER_SEQUENCE {
    pub SequenceD1: u32,
    pub SequenceD2: u32,
    pub SequenceD3: u32,
}
impl Copy for POWER_SEQUENCE {}
impl Clone for POWER_SEQUENCE {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub union POWER_STATE {
    pub SystemState: SYSTEM_POWER_STATE,
    pub DeviceState: DEVICE_POWER_STATE,
}
impl Copy for POWER_STATE {}
impl Clone for POWER_STATE {
    fn clone(&self) -> Self {
        *self
    }
}
pub type POWER_STATE_TYPE = i32;
#[repr(C)]
pub struct PRIVILEGE_SET {
    pub PrivilegeCount: u32,
    pub Control: u32,
    pub Privilege: [LUID_AND_ATTRIBUTES; 1],
}
impl Copy for PRIVILEGE_SET {}
impl Clone for PRIVILEGE_SET {
    fn clone(&self) -> Self {
        *self
    }
}
pub type PSECURITY_DESCRIPTOR = *mut core::ffi::c_void;
pub type PSID = *mut core::ffi::c_void;
pub type PSTR = *mut u8;
pub type PWSTR = *mut u16;
#[repr(C)]
pub struct SECTION_OBJECT_POINTERS {
    pub DataSectionObject: *mut core::ffi::c_void,
    pub SharedCacheMap: *mut core::ffi::c_void,
    pub ImageSectionObject: *mut core::ffi::c_void,
}
impl Copy for SECTION_OBJECT_POINTERS {}
impl Clone for SECTION_OBJECT_POINTERS {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct SECURITY_DESCRIPTOR {
    pub Revision: u8,
    pub Sbz1: u8,
    pub Control: SECURITY_DESCRIPTOR_CONTROL,
    pub Owner: PSID,
    pub Group: PSID,
    pub Sacl: *mut ACL,
    pub Dacl: *mut ACL,
}
impl Copy for SECURITY_DESCRIPTOR {}
impl Clone for SECURITY_DESCRIPTOR {
    fn clone(&self) -> Self {
        *self
    }
}
pub type SECURITY_DESCRIPTOR_CONTROL = u16;
pub type SECURITY_IMPERSONATION_LEVEL = i32;
#[repr(C)]
pub struct SECURITY_QUALITY_OF_SERVICE {
    pub Length: u32,
    pub ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    pub ContextTrackingMode: u8,
    pub EffectiveOnly: BOOLEAN,
}
impl Copy for SECURITY_QUALITY_OF_SERVICE {}
impl Clone for SECURITY_QUALITY_OF_SERVICE {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct SECURITY_SUBJECT_CONTEXT {
    pub ClientToken: *mut core::ffi::c_void,
    pub ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    pub PrimaryToken: *mut core::ffi::c_void,
    pub ProcessAuditId: *mut core::ffi::c_void,
}
impl Copy for SECURITY_SUBJECT_CONTEXT {}
impl Clone for SECURITY_SUBJECT_CONTEXT {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct SID {
    pub Revision: u8,
    pub SubAuthorityCount: u8,
    pub IdentifierAuthority: SID_IDENTIFIER_AUTHORITY,
    pub SubAuthority: [u32; 1],
}
impl Copy for SID {}
impl Clone for SID {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct SID_IDENTIFIER_AUTHORITY {
    pub Value: [u8; 6],
}
impl Copy for SID_IDENTIFIER_AUTHORITY {}
impl Clone for SID_IDENTIFIER_AUTHORITY {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct SINGLE_LIST_ENTRY {
    pub Next: *mut SINGLE_LIST_ENTRY,
}
impl Copy for SINGLE_LIST_ENTRY {}
impl Clone for SINGLE_LIST_ENTRY {
    fn clone(&self) -> Self {
        *self
    }
}
pub type SYSTEM_POWER_STATE = i32;
#[repr(C)]
pub struct SYSTEM_POWER_STATE_CONTEXT {
    pub Anonymous: SYSTEM_POWER_STATE_CONTEXT_0,
}
impl Copy for SYSTEM_POWER_STATE_CONTEXT {}
impl Clone for SYSTEM_POWER_STATE_CONTEXT {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub union SYSTEM_POWER_STATE_CONTEXT_0 {
    pub Anonymous: SYSTEM_POWER_STATE_CONTEXT_0_0,
    pub ContextAsUlong: u32,
}
impl Copy for SYSTEM_POWER_STATE_CONTEXT_0 {}
impl Clone for SYSTEM_POWER_STATE_CONTEXT_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct SYSTEM_POWER_STATE_CONTEXT_0_0 {
    pub _bitfield: u32,
}
impl Copy for SYSTEM_POWER_STATE_CONTEXT_0_0 {}
impl Clone for SYSTEM_POWER_STATE_CONTEXT_0_0 {
    fn clone(&self) -> Self {
        *self
    }
}
pub type TOKEN_PRIVILEGES_ATTRIBUTES = u32;
#[repr(C)]
pub struct UNICODE_STRING {
    pub Length: u16,
    pub MaximumLength: u16,
    pub Buffer: PWSTR,
}
impl Copy for UNICODE_STRING {}
impl Clone for UNICODE_STRING {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct VPB {
    pub Type: i16,
    pub Size: i16,
    pub Flags: u16,
    pub VolumeLabelLength: u16,
    pub DeviceObject: *mut DEVICE_OBJECT,
    pub RealDevice: *mut DEVICE_OBJECT,
    pub SerialNumber: u32,
    pub ReferenceCount: u32,
    pub VolumeLabel: [u16; 32],
}
impl Copy for VPB {}
impl Clone for VPB {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct WAIT_CONTEXT_BLOCK {
    pub Anonymous: WAIT_CONTEXT_BLOCK_0,
    pub DeviceRoutine: *mut DRIVER_CONTROL,
    pub DeviceContext: *mut core::ffi::c_void,
    pub NumberOfMapRegisters: u32,
    pub DeviceObject: *mut core::ffi::c_void,
    pub CurrentIrp: *mut core::ffi::c_void,
    pub BufferChainingDpc: *mut KDPC,
}
impl Copy for WAIT_CONTEXT_BLOCK {}
impl Clone for WAIT_CONTEXT_BLOCK {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub union WAIT_CONTEXT_BLOCK_0 {
    pub WaitQueueEntry: KDEVICE_QUEUE_ENTRY,
    pub Anonymous: WAIT_CONTEXT_BLOCK_0_0,
}
impl Copy for WAIT_CONTEXT_BLOCK_0 {}
impl Clone for WAIT_CONTEXT_BLOCK_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
pub struct WAIT_CONTEXT_BLOCK_0_0 {
    pub DmaWaitEntry: LIST_ENTRY,
    pub NumberOfChannels: u32,
    pub _bitfield: u32,
}
impl Copy for WAIT_CONTEXT_BLOCK_0_0 {}
impl Clone for WAIT_CONTEXT_BLOCK_0_0 {
    fn clone(&self) -> Self {
        *self
    }
}
pub type _DEVICE_OBJECT_POWER_EXTENSION = isize;
pub type _IORING_OBJECT = isize;
pub type _SCSI_REQUEST_BLOCK = isize;
